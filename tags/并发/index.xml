<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>并发 on luanrz's blog</title><link>https://luanrz.github.io/tags/%E5%B9%B6%E5%8F%91/</link><description>Recent content in 并发 on luanrz's blog</description><generator>Hugo -- 0.155.3</generator><language>zh-cn</language><lastBuildDate>Sat, 20 Aug 2022 16:54:26 +0000</lastBuildDate><atom:link href="https://luanrz.github.io/tags/%E5%B9%B6%E5%8F%91/index.xml" rel="self" type="application/rss+xml"/><item><title>Java线程池简介</title><link>https://luanrz.github.io/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AE%80%E4%BB%8B/</link><pubDate>Sat, 20 Aug 2022 16:54:26 +0000</pubDate><guid>https://luanrz.github.io/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AE%80%E4%BB%8B/</guid><description>&lt;p&gt;一般来说，Java中每一个任务都与其对应的线程共享生命周期，任务执行完毕后其线程也会跟着销毁，随着任务数量的增加，重复创建线程所带来的消耗所产生的性能影响也会更显著。线程池提供了一种复用多个线程的方案，以此避免无谓的线程创建，它通过管理线程们的生命周期和调度方式，为任务的批量执行提供更强的灵活性。&lt;/p&gt;
&lt;p&gt;线程池主要是指&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;类，本文将围绕&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;类及其相关类，展开对线程池的介绍。&lt;/p&gt;</description></item><item><title>Java阻塞队列简介</title><link>https://luanrz.github.io/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%AE%80%E4%BB%8B/</link><pubDate>Mon, 01 Aug 2022 17:00:00 +0000</pubDate><guid>https://luanrz.github.io/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%AE%80%E4%BB%8B/</guid><description>&lt;p&gt;Java阻塞队列是一种可以实现&lt;strong&gt;阻塞插入&lt;/strong&gt;和&lt;strong&gt;阻塞移除&lt;/strong&gt;的特殊队列，它被广泛应用于生产者消费者模式。如在线程池中，可以使用&lt;code&gt;LinkedBlockingQueue&lt;/code&gt;与&lt;code&gt;SynchronousQueue&lt;/code&gt;等阻塞队列来生产与消费线程对象。&lt;/p&gt;
&lt;p&gt;下面将简单介绍Java中常用的几个阻塞队列。&lt;/p&gt;</description></item><item><title>Java锁简介</title><link>https://luanrz.github.io/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E9%94%81%E7%AE%80%E4%BB%8B/</link><pubDate>Wed, 06 Jul 2022 11:15:36 +0000</pubDate><guid>https://luanrz.github.io/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E9%94%81%E7%AE%80%E4%BB%8B/</guid><description>&lt;p&gt;Java锁(Lock)是实现Java线程安全的一种手段，它通过加锁和解锁的过程来实现线程间的同步，以保证多线程在竞争同一个公共资源时数据读写的正确性。&lt;/p&gt;
&lt;p&gt;本文将首先阐明&lt;a href="#%E4%B8%80%E5%89%8D%E8%A8%80"&gt;Lock在Java线程安全中的位置&lt;/a&gt;，随后将简单介绍&lt;a href="#%E4%BA%8Clock%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"&gt;&lt;code&gt;Lock&lt;/code&gt;类之间的关系&lt;/a&gt;，最后将简单介绍Java锁的&lt;a href="#%E4%B8%89java%E9%94%81%E7%9A%84%E6%8A%BD%E8%B1%A1%E5%AE%9A%E4%B9%89"&gt;抽象定义&lt;/a&gt;与&lt;a href="#%E5%9B%9Bjava%E9%94%81%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"&gt;具体实现&lt;/a&gt;。&lt;/p&gt;</description></item><item><title>ThreadLocal原理浅析</title><link>https://luanrz.github.io/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/threadlocal%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</link><pubDate>Mon, 18 Apr 2022 10:01:31 +0000</pubDate><guid>https://luanrz.github.io/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/threadlocal%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</guid><description>&lt;p&gt;ThreadLocal是一种实现线程安全的机制，它提供了访问线程局部变量（thread-local variables）的方法，线程局部变量与普通变量的不同之处在于，线程局部变量在每一个线程中的值都是独立的，这保证了在多线程环境下不会出现线程串用的问题。&lt;/p&gt;</description></item><item><title>Java单例模式中的一个多线程问题</title><link>https://luanrz.github.io/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98/</link><pubDate>Fri, 15 Apr 2022 14:43:37 +0000</pubDate><guid>https://luanrz.github.io/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98/</guid><description>&lt;p&gt;合理使用单例模式可以节约内存资源，但错误的使用可能会导致严重的生产问题，如：多线程下，一个线程可能会覆盖上一个线程的单例属性，导致两次不同的请求得到同样的响应。&lt;/p&gt;
&lt;p&gt;下面将结合一个例子来分析这种情况。&lt;/p&gt;</description></item></channel></rss>