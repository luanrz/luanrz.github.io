<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Java应用部署K8S全流程：Docker镜像制作、Harbor镜像存储与Helm应用部署 | luanrz's blog</title><meta name=keywords content="K8S,Docker,Java"><meta name=description content="一、前言
Java应用部署到K8S（Kubernetes），一般需要镜像制作、镜像存储与应用部署这三个步骤。

镜像制作：根据Java源代码生成符合OCI（开放容器标准）的镜像。可以使用Docker完成镜像制作。
镜像存储：将镜像上传到镜像仓库以便后续使用。这里的镜像仓库一般是指Harbor。
应用部署：根据镜像仓库中的镜像及其对应配置，将应用部署到K8S集群。K8S原生支持手动编写配置文件实现应用部署，Helm简化了应用部署的过程。

为了更好地理解云环境部署，可以类比传统的虚机部署。在云环境部署中："><meta name=author content><link rel=canonical href=https://luanrz.github.io/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2k8s%E5%85%A8%E6%B5%81%E7%A8%8Bdocker%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9Charbor%E9%95%9C%E5%83%8F%E4%B8%8A%E4%BC%A0%E4%B8%8Ehelm%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2/><link crossorigin=anonymous href=/assets/css/stylesheet.ed6c30fee125be816b653632a2732f92313b593583d98576c9eb2bf33a42b6e1.css integrity="sha256-7Www/uElvoFrZTYyonMvkjE7WTWD2YV2yesr8zpCtuE=" rel="preload stylesheet" as=style><link rel=icon href=https://luanrz.github.io/images/icon.jpg><link rel=icon type=image/png sizes=16x16 href=https://luanrz.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://luanrz.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://luanrz.github.io/apple-touch-icon.png><link rel=mask-icon href=https://luanrz.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://luanrz.github.io/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2k8s%E5%85%A8%E6%B5%81%E7%A8%8Bdocker%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9Charbor%E9%95%9C%E5%83%8F%E4%B8%8A%E4%BC%A0%E4%B8%8Ehelm%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script>const loadScript=(e,t)=>{var n=document.createElement("script");n.onerror=e=>{throw new URIError("The script "+e.target.src+" didn't load correctly.")},t&&(n.onload=t),document.head.insertAdjacentElement("beforeend",n),n.src=e},loadPlantUMLOnNeed=()=>{let e="language-plantuml";document.querySelectorAll("[class^="+e+"]").length>0&&loadScript("https://fastly.jsdelivr.net/gh/jmnote/plantuml-encoder@1.2.4/dist/plantuml-encoder.min.js",()=>{(function(){Array.prototype.forEach.call(document.querySelectorAll("[class^="+e+"]"),function(e){let t=document.createElement("IMG");t.loading="lazy",t.src="http://www.plantuml.com/plantuml/svg/~1"+plantumlEncoder.encode(e.innerText),e.parentNode.insertBefore(t,e),e.style.display="none"})})(),console.log("PlantUML init done")})};window.addEventListener("load",function(){loadPlantUMLOnNeed()})</script><meta property="og:url" content="https://luanrz.github.io/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2k8s%E5%85%A8%E6%B5%81%E7%A8%8Bdocker%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9Charbor%E9%95%9C%E5%83%8F%E4%B8%8A%E4%BC%A0%E4%B8%8Ehelm%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2/"><meta property="og:site_name" content="luanrz's blog"><meta property="og:title" content="Java应用部署K8S全流程：Docker镜像制作、Harbor镜像存储与Helm应用部署"><meta property="og:description" content="一、前言 Java应用部署到K8S（Kubernetes），一般需要镜像制作、镜像存储与应用部署这三个步骤。
镜像制作：根据Java源代码生成符合OCI（开放容器标准）的镜像。可以使用Docker完成镜像制作。 镜像存储：将镜像上传到镜像仓库以便后续使用。这里的镜像仓库一般是指Harbor。 应用部署：根据镜像仓库中的镜像及其对应配置，将应用部署到K8S集群。K8S原生支持手动编写配置文件实现应用部署，Helm简化了应用部署的过程。 为了更好地理解云环境部署，可以类比传统的虚机部署。在云环境部署中："><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-12-11T11:01:19+08:00"><meta property="article:modified_time" content="2022-12-11T11:01:19+08:00"><meta property="article:tag" content="K8S"><meta property="article:tag" content="Docker"><meta property="article:tag" content="Java"><meta name=twitter:card content="summary"><meta name=twitter:title content="Java应用部署K8S全流程：Docker镜像制作、Harbor镜像存储与Helm应用部署"><meta name=twitter:description content="一、前言
Java应用部署到K8S（Kubernetes），一般需要镜像制作、镜像存储与应用部署这三个步骤。

镜像制作：根据Java源代码生成符合OCI（开放容器标准）的镜像。可以使用Docker完成镜像制作。
镜像存储：将镜像上传到镜像仓库以便后续使用。这里的镜像仓库一般是指Harbor。
应用部署：根据镜像仓库中的镜像及其对应配置，将应用部署到K8S集群。K8S原生支持手动编写配置文件实现应用部署，Helm简化了应用部署的过程。

为了更好地理解云环境部署，可以类比传统的虚机部署。在云环境部署中："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://luanrz.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Java应用部署K8S全流程：Docker镜像制作、Harbor镜像存储与Helm应用部署","item":"https://luanrz.github.io/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2k8s%E5%85%A8%E6%B5%81%E7%A8%8Bdocker%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9Charbor%E9%95%9C%E5%83%8F%E4%B8%8A%E4%BC%A0%E4%B8%8Ehelm%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Java应用部署K8S全流程：Docker镜像制作、Harbor镜像存储与Helm应用部署","name":"Java应用部署K8S全流程：Docker镜像制作、Harbor镜像存储与Helm应用部署","description":"一、前言 Java应用部署到K8S（Kubernetes），一般需要镜像制作、镜像存储与应用部署这三个步骤。\n镜像制作：根据Java源代码生成符合OCI（开放容器标准）的镜像。可以使用Docker完成镜像制作。 镜像存储：将镜像上传到镜像仓库以便后续使用。这里的镜像仓库一般是指Harbor。 应用部署：根据镜像仓库中的镜像及其对应配置，将应用部署到K8S集群。K8S原生支持手动编写配置文件实现应用部署，Helm简化了应用部署的过程。 为了更好地理解云环境部署，可以类比传统的虚机部署。在云环境部署中：\n","keywords":["K8S","Docker","Java"],"articleBody":"一、前言 Java应用部署到K8S（Kubernetes），一般需要镜像制作、镜像存储与应用部署这三个步骤。\n镜像制作：根据Java源代码生成符合OCI（开放容器标准）的镜像。可以使用Docker完成镜像制作。 镜像存储：将镜像上传到镜像仓库以便后续使用。这里的镜像仓库一般是指Harbor。 应用部署：根据镜像仓库中的镜像及其对应配置，将应用部署到K8S集群。K8S原生支持手动编写配置文件实现应用部署，Helm简化了应用部署的过程。 为了更好地理解云环境部署，可以类比传统的虚机部署。在云环境部署中：\n镜像制作就相当于：maven打包生成war包（实际上war包是镜像的一部分）。 镜像存储就相当于：将war包上传到Maven仓库。 应用部署就相当于：将Maven仓库中的war包安装到JBoss容器。 在此正式介绍上述三个过程之前，还需要准备一些环境。除了Java基础环境之外，还需要准备一个Docker环境与Kubernete集群（可以使用minikube）。\n国内网络环境启动minikube时，可以使用：minikube start --image-mirror-country='cn' --kubernetes-version=v1.23.13指令，其中，cn表示使用国内镜像，v1.23.13指定K8S版本小于v1.24，具体原因参见Kubernetes 1.24 中的移除和弃用。\n二、Docker镜像制作 Docker制作的镜像符合OCI标准，可以直接在K8S中运行。本地制作的镜像一般需要上传到Harbor仓库。\n（一）准备一个Java项目 使用spring-web搭建一个简单的web项目，pom文件如下：\n... org.springframework.boot spring-boot-starter-web org.springframework.boot spring-boot-maven-plugin ... 启动类如下：\n@SpringBootApplication @RestController public class Application { @RequestMapping(\"/index.html\") public String home() throws InterruptedException { return \"Hello World\"; } public static void main(String[] args) { SpringApplication.run(Application.class, args); } } （二）编写Dockerfile脚本 在项目根目录下新建文件Dockerfile，内容如下：\nFROM maven:3.8.4-openjdk-8-slim AS base WORKDIR /app COPY pom.xml ./ RUN --mount=type=cache,target=/root/.m2 mvn dependency:go-offline COPY src ./src FROM base AS build RUN --mount=type=cache,target=/root/.m2 mvn package FROM openjdk:8-jre-slim-buster AS production EXPOSE 8080 COPY --from=build /app/target/*.jar /app/app.jar CMD java -jar /app/app.jar 其中，--mount语法需要启用Docker的BuildKit功能，mvn dependency:go-offline表示缓存maven包以供后续重复使用。\n（三）生成Docker镜像 在项目根目录进入终端，执行docker build命令：\ndocker build -t app:0.0.1 .\n查看镜像是否成功生成：\ndocker images\n如果有看到REPOSITORY为app且TAG为0.0.1的记录，证明镜像制作完成。\n三、Harbor镜像存储 Harbor是用来存储符合OCI标准镜像的一种仓库实现，Docker客户端、K8S集群都可以从Harbor仓库拉取指定镜像。在Helm应用部署中的镜像仓库配置中，同样可以使用Harbor仓库。\n（一）安装Harbor Harbor的具体安装过程可以跟着官方安装教程走，安装过程不复杂，简而言之就是：下载安装包、修改配置文件、执行安装脚本三步走。\n这里有一点需要特别说明，当前Harbor支持HTTP与HTTPS两种访问方式，正常来说，本地测试使用HTTP就可以了，但Helm限制了Harbor的访问协议必须是HTTPS，因此还需要为HTTPS配置一些额外的证书。\n在Harbor启用SSL后，客户端需要配置ca.crt证书，否则在拉取镜像时会报x509验证错误。这里的客户端可以是Docker，也可以是K8S，下面分别介绍这两种客户端的配置方法。\n（1） Docker客户端配置SSL\n将ca.crt放入指定目录，Linux系统位于/etc/docker/certs.d/，windows系统位于%HOMEPATH%/.docker/certs.d/，有关Docker客户端SSL验证详见官方文档。\n这里的ca.crt可以手动生成，也可以使用下面介绍的minikube自带的ca.crt。\nWindows系统也可以可以双击ca.crt文件以导入证书。\n（2） K8S客户端配置SSL（以minikube为例）\nminikube的~/.minikube目录下已经有了ca.crt文件，直接使用这个文件即可，可以跳过Harbor配置HTTPS的官方文档中的Generate a Server Certificate这一步。\n至此，根据上面的流程已经配置好了可以通过HTTPS访问的Harbor服务：https://harbor.local.com，这个域名是自定义的，可以在Harbor配置安装的时候手动指定。同时，需要在hosts文件中配置对应的dns映射。\n（二）验证Harbor 验证Harbor连通性最简单的访问方式就是在浏览器中访问对应的Harbor服务，域名为https://harbor.local.com，默认用户名密码为admin与Harbor12345。\n同时，也可以使用docker login验证Harbor连通性，在终端输入docker login harbor.local.com，接着输入对应的用户名密码，提示Login Succeeded，即证明Harbor正常连通。\n（三）上传镜像到Harbor 上传之前，先要确保已经通过docker login完成了Harbor仓库的鉴权。\n然后，执行docker push命令将之前制作的镜像推送到Harbor：\ndocker push app:0.0.1 执行完毕后，会发现报了以下错误：\nThe push refers to repository [docker.io/library/app] An image does not exist locally with the tag: app 如果没有指定app的前缀，那么docker push命令会默认使用dockerhub的自带仓库，这与预期不符，因此需要手动给该镜像加上一个仓库路径前缀。如下所示：\ndocker tag app:0.0.1 harbor.local.com/luanrz/app:0.0.1 此命令会生成一条新的image记录，它的IMAGE ID与原来的镜像一致，现在，重新推送：\ndocker push harbor.local.com/luanrz/app:0.0.1 又会报一条错：\nunauthorized: project luanrz not found: project luanrz not found 可以看到是luanrz这个项目没有创建，登录到Harbor页面，点击“新建项目”，创建对应的项目。\n再次执行docker push进行推送，如果没有问题将显示推送成功的结果。至此，镜像成功上传到Harbor仓库。\n四、Helm应用部署 Helm是K8s中的包管理器，类似于Linux中pacman、apt、yum等包管理器的职责。Helm简化了安装应用到K8S的过程。\n（一）安装Helm 可以参照官方教程完成Helm的安装，这里不再赘述。安装完之后，在控制台输入helm version正常输出结果即证明安装成功。\n（二）制作Chart 首先，创建一个Helm Chart：\nhelm create app 进入app后，修改values.yaml文件：\n... image: repository: harbor.local.com/luanrz/app pullPolicy: Always tag: \"latest\" ... service: type: ClusterIP port: 8080 ... 其中，image.repository与image.tag唯一定位了一个Harbor仓库中的镜像地址，service.port则表明了对外暴露的服务端口。\n（三）安装应用 在app目录下执行：\nhelm install app . 如果执行无误，将会打印出当前Release的状态，通过helm list可查看所有的Release。\n正常情况下，helm会将values文件与templates文件组合成应用部署的相关指令，发给K8S集群，后续就可以使用kubelet控制集群中的应用了。\n（四）验证应用 执行kubectl get系列命令查看deployments、pods与services的状态：\nkubectl get deployments kubectl get pods kubectl get services 正常情况下上述资源都会有一条对应的app记录，如果pod状态不是Running，可以通过kubectl describe查看事件（Events）排查原因：\nkubectl describe pods 比如，在Harbor镜像拉取失败时，就可能出现类似于以下的各种原因：\nHarbor只配置了HTTP访问模式，此时会报错提示不支持http访问方式或重定向至https失败（解决方案：将Harbor的访问模式配置为HTTPS） Harbor配置了HTTPS访问模式，此时可能也会报错提示x509验证失败（解决方案：详见安装Harbor中的SSL相关说明） 其它等等 排查原因解决问题后，如果一切无误，应用也就部署成功了。但外面可能还没办法访问，可以通过ingress或者port-forward进一步暴露服务端口，下面以port-forward为例：\nkubectl port-forward services/ 8080:8080 现在，可以在外面访问容器应用了：\ncurl http://localhost:8080/index.html 控制台正常输入Hello World，应用部署到此结束。\n五、总结 Java应用部署到K8S按照顺序执行以下步骤：\n镜像制作：使用docker build指令生成Docker镜像。 镜像存储：使用docker login指令和docker push指令登录到并推送Harbor仓库，需要针对针对Docker客户端和K8S集群调整Harbor的SSL配置。 应用部署：使用helm create创建一个Chart，使用helm install安装一个Release，使用Kubelet系列指令管理部署完成的应用。 至此，一个Java应用，从源代码，到镜像制作、镜像存储，最后到应用部署，完成了它上云全部步骤，后面的维护和管理，将是更大的挑战。\n","wordCount":"3557","inLanguage":"zh","datePublished":"2022-12-11T11:01:19+08:00","dateModified":"2022-12-11T11:01:19+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://luanrz.github.io/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2k8s%E5%85%A8%E6%B5%81%E7%A8%8Bdocker%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9Charbor%E9%95%9C%E5%83%8F%E4%B8%8A%E4%BC%A0%E4%B8%8Ehelm%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2/"},"publisher":{"@type":"Organization","name":"luanrz's blog","logo":{"@type":"ImageObject","url":"https://luanrz.github.io/images/icon.jpg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://luanrz.github.io/ accesskey=h title="luanrz's blog (Alt + H)">luanrz's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://luanrz.github.io/ title=首页><span>首页</span></a></li><li><a href=https://luanrz.github.io/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://luanrz.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://luanrz.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://luanrz.github.io/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Java应用部署K8S全流程：Docker镜像制作、Harbor镜像存储与Helm应用部署</h1><div class=post-meta><span title='2022-12-11 11:01:19 +0800 +0800'>2022-12-11</span>&nbsp;·&nbsp;8 分钟&nbsp;·&nbsp;3557 字</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e4%b8%80%e5%89%8d%e8%a8%80 aria-label=一、前言>一、前言</a></li><li><a href=#%e4%ba%8cdocker%e9%95%9c%e5%83%8f%e5%88%b6%e4%bd%9c aria-label=二、Docker镜像制作>二、Docker镜像制作</a><ul><li><a href=#%e4%b8%80%e5%87%86%e5%a4%87%e4%b8%80%e4%b8%aajava%e9%a1%b9%e7%9b%ae aria-label=（一）准备一个Java项目>（一）准备一个Java项目</a></li><li><a href=#%e4%ba%8c%e7%bc%96%e5%86%99dockerfile%e8%84%9a%e6%9c%ac aria-label=（二）编写Dockerfile脚本>（二）编写Dockerfile脚本</a></li><li><a href=#%e4%b8%89%e7%94%9f%e6%88%90docker%e9%95%9c%e5%83%8f aria-label=（三）生成Docker镜像>（三）生成Docker镜像</a></li></ul></li><li><a href=#%e4%b8%89harbor%e9%95%9c%e5%83%8f%e5%ad%98%e5%82%a8 aria-label=三、Harbor镜像存储>三、Harbor镜像存储</a><ul><li><a href=#%e4%b8%80%e5%ae%89%e8%a3%85harbor aria-label=（一）安装Harbor>（一）安装Harbor</a></li><li><a href=#%e4%ba%8c%e9%aa%8c%e8%af%81harbor aria-label=（二）验证Harbor>（二）验证Harbor</a></li><li><a href=#%e4%b8%89%e4%b8%8a%e4%bc%a0%e9%95%9c%e5%83%8f%e5%88%b0harbor aria-label=（三）上传镜像到Harbor>（三）上传镜像到Harbor</a></li></ul></li><li><a href=#%e5%9b%9bhelm%e5%ba%94%e7%94%a8%e9%83%a8%e7%bd%b2 aria-label=四、Helm应用部署>四、Helm应用部署</a><ul><li><a href=#%e4%b8%80%e5%ae%89%e8%a3%85helm aria-label=（一）安装Helm>（一）安装Helm</a></li><li><a href=#%e4%ba%8c%e5%88%b6%e4%bd%9cchart aria-label=（二）制作Chart>（二）制作Chart</a></li><li><a href=#%e4%b8%89%e5%ae%89%e8%a3%85%e5%ba%94%e7%94%a8 aria-label=（三）安装应用>（三）安装应用</a></li><li><a href=#%e5%9b%9b%e9%aa%8c%e8%af%81%e5%ba%94%e7%94%a8 aria-label=（四）验证应用>（四）验证应用</a></li></ul></li><li><a href=#%e4%ba%94%e6%80%bb%e7%bb%93 aria-label=五、总结>五、总结</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement||=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e}),elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=一前言>一、前言<a hidden class=anchor aria-hidden=true href=#一前言>#</a></h2><p>Java应用部署到K8S（Kubernetes），一般需要镜像制作、镜像存储与应用部署这三个步骤。</p><ul><li>镜像制作：根据Java源代码生成符合OCI（开放容器标准）的镜像。可以使用<code>Docker</code>完成镜像制作。</li><li>镜像存储：将镜像上传到镜像仓库以便后续使用。这里的镜像仓库一般是指<code>Harbor</code>。</li><li>应用部署：根据镜像仓库中的镜像及其对应配置，将应用部署到K8S集群。K8S原生支持手动编写配置文件实现应用部署，<code>Helm</code>简化了应用部署的过程。</li></ul><p>为了更好地理解云环境部署，可以类比传统的虚机部署。在云环境部署中：</p><ul><li>镜像制作就相当于：maven打包生成war包（实际上war包是镜像的一部分）。</li><li>镜像存储就相当于：将war包上传到Maven仓库。</li><li>应用部署就相当于：将Maven仓库中的war包安装到JBoss容器。</li></ul><p>在此正式介绍上述三个过程之前，还需要准备一些环境。除了Java基础环境之外，还需要准备一个<a href=https://docs.docker.com/get-docker/>Docker</a>环境与Kubernete集群（可以使用<a href=https://minikube.sigs.k8s.io/docs/start/>minikube</a>）。</p><blockquote><p>国内网络环境启动minikube时，可以使用：<code>minikube start --image-mirror-country='cn' --kubernetes-version=v1.23.13</code>指令，其中，<code>cn</code>表示使用国内镜像，<code>v1.23.13</code>指定K8S版本小于<code>v1.24</code>，具体原因参见<a href=https://kubernetes.io/zh-cn/blog/2022/04/07/upcoming-changes-in-kubernetes-1-24/>Kubernetes 1.24 中的移除和弃用</a>。</p></blockquote><h2 id=二docker镜像制作>二、Docker镜像制作<a hidden class=anchor aria-hidden=true href=#二docker镜像制作>#</a></h2><p>Docker制作的镜像符合OCI标准，可以直接在K8S中运行。本地制作的镜像一般需要上传到<a href=#%E4%B8%89harbor%E9%95%9C%E5%83%8F%E5%AD%98%E5%82%A8>Harbor仓库</a>。</p><h3 id=一准备一个java项目>（一）准备一个Java项目<a hidden class=anchor aria-hidden=true href=#一准备一个java项目>#</a></h3><p>使用spring-web搭建一个简单的web项目，pom文件如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;project&gt;</span>
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;dependencies&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;dependency&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>&lt;groupId&gt;</span>org.springframework.boot<span style=color:#f92672>&lt;/groupId&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>&lt;artifactId&gt;</span>spring-boot-starter-web<span style=color:#f92672>&lt;/artifactId&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;/dependency&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;/dependencies&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;build&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;plugins&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>&lt;plugin&gt;</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>&lt;groupId&gt;</span>org.springframework.boot<span style=color:#f92672>&lt;/groupId&gt;</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>&lt;artifactId&gt;</span>spring-boot-maven-plugin<span style=color:#f92672>&lt;/artifactId&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>&lt;/plugin&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;/plugins&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;/build&gt;</span>
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/project&gt;</span>
</span></span></code></pre></div><p>启动类如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@SpringBootApplication</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@RestController</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Application</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@RequestMapping</span>(<span style=color:#e6db74>&#34;/index.html&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>home</span>() <span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;Hello World&#34;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        SpringApplication.<span style=color:#a6e22e>run</span>(Application.<span style=color:#a6e22e>class</span>, args);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=二编写dockerfile脚本>（二）编写Dockerfile脚本<a hidden class=anchor aria-hidden=true href=#二编写dockerfile脚本>#</a></h3><p>在项目根目录下新建文件<code>Dockerfile</code>，内容如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:#66d9ef>FROM</span> <span style=color:#e6db74>maven:3.8.4-openjdk-8-slim</span> <span style=color:#66d9ef>AS</span> <span style=color:#e6db74>base</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span> <span style=color:#e6db74>/app</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> pom.xml ./<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> --mount<span style=color:#f92672>=</span>type<span style=color:#f92672>=</span>cache,target<span style=color:#f92672>=</span>/root/.m2 mvn dependency:go-offline<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> src ./src<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>FROM</span> <span style=color:#e6db74>base</span> <span style=color:#66d9ef>AS</span> <span style=color:#e6db74>build</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> --mount<span style=color:#f92672>=</span>type<span style=color:#f92672>=</span>cache,target<span style=color:#f92672>=</span>/root/.m2 mvn package<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>FROM</span> <span style=color:#e6db74>openjdk:8-jre-slim-buster</span> <span style=color:#66d9ef>AS</span> <span style=color:#e6db74>production</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>EXPOSE</span> <span style=color:#e6db74>8080</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> --from<span style=color:#f92672>=</span>build /app/target/*.jar /app/app.jar<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>CMD</span> java -jar /app/app.jar<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>其中，<code>--mount</code>语法需要启用Docker的<a href=https://docs.docker.com/build/buildkit/>BuildKit</a>功能，<code>mvn dependency:go-offline</code>表示缓存maven包以供后续重复使用。</p><h3 id=三生成docker镜像>（三）生成Docker镜像<a hidden class=anchor aria-hidden=true href=#三生成docker镜像>#</a></h3><p>在项目根目录进入终端，执行<code>docker build</code>命令：</p><p><code>docker build -t app:0.0.1 .</code></p><p>查看镜像是否成功生成：</p><p><code>docker images</code></p><p>如果有看到<code>REPOSITORY</code>为<code>app</code>且<code>TAG</code>为<code>0.0.1</code>的记录，证明镜像制作完成。</p><h2 id=三harbor镜像存储>三、Harbor镜像存储<a hidden class=anchor aria-hidden=true href=#三harbor镜像存储>#</a></h2><p>Harbor是用来存储符合OCI标准镜像的一种仓库实现，Docker客户端、K8S集群都可以从Harbor仓库拉取指定镜像。在<a href=#%E5%9B%9Bhelm%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2>Helm应用部署</a>中的镜像仓库配置中，同样可以使用Harbor仓库。</p><h3 id=一安装harbor>（一）安装Harbor<a hidden class=anchor aria-hidden=true href=#一安装harbor>#</a></h3><p>Harbor的具体安装过程可以跟着<a href=https://goharbor.io/docs/2.6.0/install-config/>官方安装教程</a>走，安装过程不复杂，简而言之就是：下载安装包、修改配置文件、执行安装脚本三步走。</p><p>这里有一点需要特别说明，当前Harbor支持HTTP与HTTPS两种访问方式，正常来说，本地测试使用HTTP就可以了，但Helm限制了Harbor的访问协议必须是HTTPS，因此还需要为HTTPS配置一些额外的证书。</p><p>在Harbor启用SSL后，客户端需要配置ca.crt证书，否则在拉取镜像时会报x509验证错误。这里的客户端可以是Docker，也可以是K8S，下面分别介绍这两种客户端的配置方法。</p><p>（1） Docker客户端配置SSL</p><p>将ca.crt放入指定目录，Linux系统位于<code>/etc/docker/certs.d/</code>，windows系统位于<code>%HOMEPATH%/.docker/certs.d/</code>，有关Docker客户端SSL验证详见<a href=https://docs.docker.com/engine/security/certificates/>官方文档</a>。</p><blockquote><p>这里的ca.crt可以手动生成，也可以使用下面介绍的minikube自带的ca.crt。</p></blockquote><blockquote><p>Windows系统也可以可以双击ca.crt文件以导入证书。</p></blockquote><p>（2） K8S客户端配置SSL（以minikube为例）</p><p>minikube的<code>~/.minikube</code>目录下已经有了ca.crt文件，直接使用这个文件即可，可以跳过<a href=https://goharbor.io/docs/2.6.0/install-config/configure-https/>Harbor配置HTTPS的官方文档</a>中的<a href=https://goharbor.io/docs/2.6.0/install-config/configure-https/#generate-a-server-certificate>Generate a Server Certificate</a>这一步。</p><p>至此，根据上面的流程已经配置好了可以通过HTTPS访问的Harbor服务：<code>https://harbor.local.com</code>，这个域名是自定义的，可以在Harbor配置安装的时候手动指定。同时，需要在hosts文件中配置对应的dns映射。</p><h3 id=二验证harbor>（二）验证Harbor<a hidden class=anchor aria-hidden=true href=#二验证harbor>#</a></h3><p>验证Harbor连通性最简单的访问方式就是在浏览器中访问对应的Harbor服务，域名为<code>https://harbor.local.com</code>，默认用户名密码为<code>admin</code>与<code>Harbor12345</code>。</p><p>同时，也可以使用<code>docker login</code>验证Harbor连通性，在终端输入<code>docker login harbor.local.com</code>，接着输入对应的用户名密码，提示<code>Login Succeeded</code>，即证明Harbor正常连通。</p><h3 id=三上传镜像到harbor>（三）上传镜像到Harbor<a hidden class=anchor aria-hidden=true href=#三上传镜像到harbor>#</a></h3><p>上传之前，先要确保已经通过<code>docker login</code>完成了Harbor仓库的鉴权。</p><p>然后，执行<code>docker push</code>命令将之前制作的镜像推送到Harbor：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker push app:0.0.1
</span></span></code></pre></div><p>执行完毕后，会发现报了以下错误：</p><pre tabindex=0><code class=language-log data-lang=log>The push refers to repository [docker.io/library/app]
An image does not exist locally with the tag: app
</code></pre><p>如果没有指定<code>app</code>的前缀，那么<code>docker push</code>命令会默认使用dockerhub的自带仓库，这与预期不符，因此需要手动给该镜像加上一个仓库路径前缀。如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker tag app:0.0.1 harbor.local.com/luanrz/app:0.0.1
</span></span></code></pre></div><p>此命令会生成一条新的image记录，它的IMAGE ID与原来的镜像一致，现在，重新推送：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker push harbor.local.com/luanrz/app:0.0.1
</span></span></code></pre></div><p>又会报一条错：</p><pre tabindex=0><code class=language-log data-lang=log>unauthorized: project luanrz not found: project luanrz not found
</code></pre><p>可以看到是<code>luanrz</code>这个项目没有创建，登录到Harbor页面，点击“新建项目”，创建对应的项目。</p><p>再次执行<code>docker push</code>进行推送，如果没有问题将显示推送成功的结果。至此，镜像成功上传到Harbor仓库。</p><h2 id=四helm应用部署>四、Helm应用部署<a hidden class=anchor aria-hidden=true href=#四helm应用部署>#</a></h2><p>Helm是K8s中的包管理器，类似于Linux中pacman、apt、yum等包管理器的职责。Helm简化了安装应用到K8S的过程。</p><h3 id=一安装helm>（一）安装Helm<a hidden class=anchor aria-hidden=true href=#一安装helm>#</a></h3><p>可以参照<a href=https://helm.sh/zh/docs/intro/install/>官方教程</a>完成Helm的安装，这里不再赘述。安装完之后，在控制台输入<code>helm version</code>正常输出结果即证明安装成功。</p><h3 id=二制作chart>（二）制作Chart<a hidden class=anchor aria-hidden=true href=#二制作chart>#</a></h3><p>首先，创建一个Helm Chart：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>helm create app
</span></span></code></pre></div><p>进入app后，修改<code>values.yaml</code>文件：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#f92672>image</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>repository</span>:  <span style=color:#ae81ff>harbor.local.com/luanrz/app</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>pullPolicy</span>: <span style=color:#ae81ff>Always</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>tag</span>: <span style=color:#e6db74>&#34;latest&#34;</span>
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#f92672>service</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>type</span>: <span style=color:#ae81ff>ClusterIP</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>port</span>: <span style=color:#ae81ff>8080</span>
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>其中，image.repository与image.tag唯一定位了一个Harbor仓库中的镜像地址，service.port则表明了对外暴露的服务端口。</p><h3 id=三安装应用>（三）安装应用<a hidden class=anchor aria-hidden=true href=#三安装应用>#</a></h3><p>在app目录下执行：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>helm install app .
</span></span></code></pre></div><p>如果执行无误，将会打印出当前Release的状态，通过<code>helm list</code>可查看所有的Release。</p><p>正常情况下，helm会将values文件与templates文件组合成应用部署的相关指令，发给K8S集群，后续就可以使用kubelet控制集群中的应用了。</p><h3 id=四验证应用>（四）验证应用<a hidden class=anchor aria-hidden=true href=#四验证应用>#</a></h3><p>执行<code>kubectl get</code>系列命令查看deployments、pods与services的状态：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deployments
</span></span><span style=display:flex><span>kubectl get pods
</span></span><span style=display:flex><span>kubectl get services
</span></span></code></pre></div><p>正常情况下上述资源都会有一条对应的app记录，如果pod状态不是Running，可以通过<code>kubectl describe</code>查看事件（Events）排查原因：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pods &lt;POD_NAME&gt;
</span></span></code></pre></div><p>比如，在Harbor镜像拉取失败时，就可能出现类似于以下的各种原因：</p><ul><li>Harbor只配置了HTTP访问模式，此时会报错提示不支持http访问方式或重定向至https失败（解决方案：将Harbor的访问模式配置为HTTPS）</li><li>Harbor配置了HTTPS访问模式，此时可能也会报错提示x509验证失败（解决方案：详见<a href=#%E4%B8%80%E5%AE%89%E8%A3%85harbor>安装Harbor中的SSL相关说明</a>）</li><li>其它等等</li></ul><p>排查原因解决问题后，如果一切无误，应用也就部署成功了。但外面可能还没办法访问，可以通过ingress或者port-forward进一步暴露服务端口，下面以port-forward为例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl port-forward services/&lt;pod-name&gt; 8080:8080
</span></span></code></pre></div><p>现在，可以在外面访问容器应用了：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl http://localhost:8080/index.html
</span></span></code></pre></div><p>控制台正常输入<code>Hello World</code>，应用部署到此结束。</p><h2 id=五总结>五、总结<a hidden class=anchor aria-hidden=true href=#五总结>#</a></h2><p>Java应用部署到K8S按照顺序执行以下步骤：</p><ul><li>镜像制作：使用<code>docker build</code>指令生成Docker镜像。</li><li>镜像存储：使用<code>docker login</code>指令和<code>docker push</code>指令登录到并推送Harbor仓库，需要针对针对Docker客户端和K8S集群调整Harbor的SSL配置。</li><li>应用部署：使用<code>helm create</code>创建一个Chart，使用<code>helm install</code>安装一个Release，使用Kubelet系列指令管理部署完成的应用。</li></ul><p>至此，一个Java应用，从源代码，到镜像制作、镜像存储，最后到应用部署，完成了它上云全部步骤，后面的维护和管理，将是更大的挑战。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://luanrz.github.io/tags/k8s/>K8S</a></li><li><a href=https://luanrz.github.io/tags/docker/>Docker</a></li><li><a href=https://luanrz.github.io/tags/java/>Java</a></li></ul><nav class=paginav><a class=prev href=https://luanrz.github.io/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/sleuth%E5%9C%A8k8s%E4%B8%AD%E7%9A%84%E8%BF%9E%E6%8E%A5%E9%87%8D%E7%BD%AE%E9%97%AE%E9%A2%98/><span class=title>« 上一页</span><br><span>Sleuth在K8S中的连接重置问题</span>
</a><a class=next href=https://luanrz.github.io/posts/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/%E5%91%BD%E4%BB%A4%E5%A4%87%E5%BF%98%E5%BD%95git/><span class=title>下一页 »</span><br><span>命令备忘录：Git</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://luanrz.github.io/>luanrz's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>