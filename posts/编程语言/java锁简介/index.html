<!doctype html><html lang=zh dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Java锁简介 | luanrz's blog</title><meta name=keywords content="Java,并发"><meta name=description content="Java锁(Lock)是实现Java线程安全的一种手段，它通过加锁和解锁的过程来实现线程间的同步，以保证多线程在竞争同一个公共资源时数据读写的正确性。
本文将首先阐明Lock在Java线程安全中的位置，随后将简单介绍Lock类之间的关系，最后将简单介绍Java锁的抽象定义与具体实现。"><meta name=author content><link rel=canonical href=https://luanrz.github.io/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E9%94%81%E7%AE%80%E4%BB%8B/><link crossorigin=anonymous href=/assets/css/stylesheet.5ed58f4ac5cb2b1025742e6161056c468c3232b9bfc72705b7f9f2da355ff7f3.css integrity="sha256-XtWPSsXLKxAldC5hYQVsRowyMrm/xycFt/ny2jVf9/M=" rel="preload stylesheet" as=style><link rel=icon href=https://luanrz.github.io/images/icon.jpg><link rel=icon type=image/png sizes=16x16 href=https://luanrz.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://luanrz.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://luanrz.github.io/apple-touch-icon.png><link rel=mask-icon href=https://luanrz.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://luanrz.github.io/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E9%94%81%E7%AE%80%E4%BB%8B/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script>const loadScript=(e,t)=>{var n=document.createElement("script");n.onerror=e=>{throw new URIError("The script "+e.target.src+" didn't load correctly.")},t&&(n.onload=t),document.head.insertAdjacentElement("beforeend",n),n.src=e},loadPlantUMLOnNeed=()=>{let e="language-plantuml";document.querySelectorAll("[class^="+e+"]").length>0&&loadScript("https://fastly.jsdelivr.net/gh/jmnote/plantuml-encoder@1.2.4/dist/plantuml-encoder.min.js",()=>{(function(){Array.prototype.forEach.call(document.querySelectorAll("[class^="+e+"]"),function(e){let t=document.createElement("IMG");t.loading="lazy",t.src="http://www.plantuml.com/plantuml/svg/~1"+plantumlEncoder.encode(e.innerText),e.parentNode.insertBefore(t,e),e.style.display="none"})})(),console.log("PlantUML init done")})};window.addEventListener("load",function(){loadPlantUMLOnNeed()})</script><meta property="og:url" content="https://luanrz.github.io/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E9%94%81%E7%AE%80%E4%BB%8B/"><meta property="og:site_name" content="luanrz's blog"><meta property="og:title" content="Java锁简介"><meta property="og:description" content="Java锁(Lock)是实现Java线程安全的一种手段，它通过加锁和解锁的过程来实现线程间的同步，以保证多线程在竞争同一个公共资源时数据读写的正确性。
本文将首先阐明Lock在Java线程安全中的位置，随后将简单介绍Lock类之间的关系，最后将简单介绍Java锁的抽象定义与具体实现。"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-07-06T11:15:36+00:00"><meta property="article:modified_time" content="2022-07-06T11:15:36+00:00"><meta property="article:tag" content="Java"><meta property="article:tag" content="并发"><meta name=twitter:card content="summary"><meta name=twitter:title content="Java锁简介"><meta name=twitter:description content="Java锁(Lock)是实现Java线程安全的一种手段，它通过加锁和解锁的过程来实现线程间的同步，以保证多线程在竞争同一个公共资源时数据读写的正确性。
本文将首先阐明Lock在Java线程安全中的位置，随后将简单介绍Lock类之间的关系，最后将简单介绍Java锁的抽象定义与具体实现。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://luanrz.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Java锁简介","item":"https://luanrz.github.io/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E9%94%81%E7%AE%80%E4%BB%8B/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Java锁简介","name":"Java锁简介","description":"Java锁(Lock)是实现Java线程安全的一种手段，它通过加锁和解锁的过程来实现线程间的同步，以保证多线程在竞争同一个公共资源时数据读写的正确性。\n本文将首先阐明Lock在Java线程安全中的位置，随后将简单介绍Lock类之间的关系，最后将简单介绍Java锁的抽象定义与具体实现。\n","keywords":["Java","并发"],"articleBody":"Java锁(Lock)是实现Java线程安全的一种手段，它通过加锁和解锁的过程来实现线程间的同步，以保证多线程在竞争同一个公共资源时数据读写的正确性。\n本文将首先阐明Lock在Java线程安全中的位置，随后将简单介绍Lock类之间的关系，最后将简单介绍Java锁的抽象定义与具体实现。\n一、前言 保证Java线程安全有三种方式：阻塞(互斥)同步、非阻塞同步、无同步。本文将要介绍的锁(Lock)可以是阻塞同步(如：ReentrantReadWriteLock的写操作)，也可以是非阻塞同步(如：StampedLock的tryOptimisticRead读操作)，下面将简单介绍一下这三种方式。\n互斥同步是悲观锁，悲观锁意味着“悲观地认为资源大概率会被同时访问，所以采取先加锁再操作数据的策略”，常见的实现方法是synchronized与部分Lock类，一般情况下，Lock与synchronized可以相互替换。\n非阻塞同步是乐观锁，乐观锁意味着“乐观地认为资源大概率不会被同时访问，所以采取先操作数据再判断并发状态的策略”，常见的实现方法是CAS原子操作(如：Atomic系列类)。乐观锁虽然带有锁字，但其实并没有真正加锁与解锁的过程，只是用来和悲观锁加以区分，因此也可以将之称之为无锁同步。\n除了互斥同步与非阻塞同步两种同步方案外，还有一种无同步方案，常见的实现方法是ThreadLocal与volatile等。\n二、Lock类之间的关系 与Java锁相关的10个类都在java.util.concurrent.locks包下面，它们之间的关系如下所示：\n@startuml Java锁类图 title Java锁类图 abstract class AbstractOwnableSynchronizer abstract class AbstractQueuedSynchronizer #Pink abstract class AbstractQueuedLongSynchronizer interface Condition interface Lock class LockSupport interface ReadWriteLock class ReentrantLock #Pink class ReentrantReadWriteLock #Pink class StampedLock Lock --|\u003e ReentrantLock Lock --+ ReentrantReadWriteLock Lock --+ StampedLock ReentrantLock +-- AbstractQueuedSynchronizer ReentrantReadWriteLock +-- AbstractQueuedSynchronizer ReentrantReadWriteLock \u003c|-- ReadWriteLock AbstractQueuedSynchronizer +-- Condition AbstractQueuedSynchronizer --\u003e LockSupport AbstractOwnableSynchronizer -|\u003e AbstractQueuedSynchronizer AbstractOwnableSynchronizer --|\u003e AbstractQueuedLongSynchronizer @enduml 上述大部分类都是在jdk5中新增的，其中AbstractOwnableSynchronizer与AbstractQueuedLongSynchronizer在jdk6中新增，StampedLock在jdk8中新增。\nLock接口是锁的原型，队列同步器AbstractQueuedSynchronizer(AQS)是锁的实现基础，可重入锁ReentrantLock、读写锁ReentrantReadWriteLock与增强型读写锁StampedLock是锁的三种具体实现。\n三、Java锁的抽象定义 Lock接口定义了锁的使用方法，AQS类定义了锁的实现规范。\n（一）Lock接口 在jdk5之前，一般使用synchronized关键字实现同步，jdk5后，Lock也成为了一种更灵活的可选项。这里的Lock是广义的Lock，指的是java.util.concurrent.locks包的集合，狭义的Lock接口是这个集合中的一个元素，本小节介绍的是狭义的Lock接口。\njdk后续版本，java团队从虚拟机层面对synchronized关键字做了一系列优化，如：适应性自旋、锁消除、锁膨胀、轻量级锁、偏向锁等。\nLock接口有以下主要方法：\nlock：获取锁(加锁) tryLock：尝试获取锁 unlock：释放锁 下面罗列了jdk官方文档中两种使用锁的模板：\n使用lock与unlock Lock lock = ...; //定义并实例化锁 lock.lock(); // 获取锁 try { // 操作被锁保护的资源 } finally { lock.unlock(); // 释放锁 } 使用tryLock与unlock Lock lock = ...; //定义并实例化锁 if (lock.tryLock()) { // 尝试获取锁：成功 try { // 操作被锁保护的资源 } finally { lock.unlock(); // 释放锁 } } else { // 尝试获取锁：失败 // 执行其它流程 } （二）AQS类 队列同步器AbstractQueuedSynchronizer(AQS)是Java锁的基础，后续即将介绍的三种Java锁都有对应的AQS内部类实现。\nAQS中有两个关键的数据元素：\n同步状态 同步队列 其中，同步状态是一个volatile int类型的值，该值可以表示为持有锁的个数(如2表示持有2个锁，0表示不持有锁)。AQS使用getState、setState及compareAndSetState这三个方法来获取或修改state值。同时，同步队列是一个以自定义元素Node为节点的双向链表结构，该队列可以保存同步阻塞时的节点信息。\nAQS通过acquire及release系列方法来修改上述两个数据元素，来达到同步控制的目的。在这个过程中，有5个模板方法：tryAcquire、tryRelease、tryAcquireShared、tryReleaseShared、isHeldExclusively，它们默认会抛出UnsupportedOperationException异常，AQS的实现类需要去自定义它们的逻辑。\n上面引出来了AQS中定义的一些关键方法，它们和Lock接口中的方法存在一定的依赖关系。从锁的使用到锁的实现，有以下两条调用链路：\n加锁：Lock.lock() –\u003e AQS.acquire() –\u003e AQS.tryAcquire() –\u003e xxx 解锁：Lock.unlock() –\u003e AQS.release() –\u003e AQS.tryRelease() –\u003e xxx Lock实现类的加锁和解锁过程通过AQS类来实现，Lock与AQS共同组成了Java锁的抽象定义，为后面的Java锁的具体实现做好了铺垫。\n四、Java锁的具体实现 （一）可重入锁 ReentrantLock是一个可重入的互斥锁，它与synchronized有相同的基础行为和语义，但比synchronized更有扩展性。\n上面提到了两个概念，“互斥”与“可重入”，接下来将分别简单介绍这两个词的含义：\n互斥：ReentrantLock只能被一个线程所持有，当这个线程调用lock方法获得锁，并且没有调用unlock方法释放锁时，其它线程将无法获取该锁，只能处于等待状态。\n可重入：持有锁的线程可以反复获得这个锁(比如在递归场景中)，这意味着当前线程可以重复进入被加锁的区域，而无需等待锁释放。每次执行lock方法都会导致同步状态state的值加1，执行unlock方法则会减1，lock与unlock成对生效时，才会最终释放当前线程的锁。\nReentrantLock通过构造函数中的fair来决定创建公平锁(FairSync)或非公平锁(NonfairSync)，默认为非公平锁。公平锁能够保证等待越久的线程越能优先获取到锁(通过hasQueuedPredecessors方法实现)，从而保证不同线程在获取锁阻塞时等待时间的公平性。一言以蔽之，非公平锁可以插队(不保证顺序)，而公平锁一般不能插队(保证FIFO的顺序)\n下面以一个简单的例子说明一下ReentrantLock的使用方法：\nclass StatusHolder { private int status; private final Lock lock = new ReentrantLock(); // 以传统的synchronized的方式同步修改状态 public void changeStatusWithSynchronized(int status) { synchronized (this) { this.status = status; } } // 以Lock.lock()的方式同步修改状态 public void changeStatusWithLock(int status) { lock.lock(); try { this.status = status; } finally { lock.unlock(); } } // 以Lock.tryLock()的方式同步修改状态 public void changeStatusWithTryLock(int status) { if (lock.tryLock()) { try { this.status = status; } finally { lock.unlock(); } } else { // 获取锁失败，执行其它流程 } } } 上面使用三种方法来实现“修改状态”这一功能。作为对比，第一种使用的是传统的synchronized方式，第二种与第三种则是ReentrantLock的方式。synchronized与ReentrantLock在某些情况下可以互相替换，但ReentrantLock灵活度更高(比如可以实现超时等待)。\n（二）读写锁 ReadWriteLock接口维护了一对读锁和写锁。读锁可以被多个线程共享（非互斥），而写锁只能被一个线程持有（互斥）。这一特性也表明了ReadWriteLock更适合用于读多写少的场景。\n根据读写锁的排列组合，有以下四种情况：\n一个线程持有读锁后，另一个线程尝试获取读锁 一个线程持有读锁后，另一个线程尝试获取写锁 一个线程持有写锁后，另一个线程尝试获取读锁 一个线程持有写锁后，另一个线程尝试获取写锁 ReadWriteLock中仅有第一个场景的同时读操作是共享的（这也是使用读写锁时大概率会发生的场景），其它三种情况一般情况下都是互斥的。\nReadWriteLock当前有两个实现类：ReentrantReadWriteLock与StampedLock。ReentrantReadWriteLock是可重入的读写锁，它在读写锁的基础上支持重入操作。StampedLock是增强型的读写锁，它支持在读的过程中执行写操作（也即是上述排列组合的第2中情况），使用乐观读锁与悲观读锁的组合可以避免同时读写造成的脏读现象。同时，StampedLock是不可重入的。\n接下来将以ReentrantReadWriteLock为例介绍读写锁的简单使用方法：\nclass StatusHolder { private int status; private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock(); private final Lock readLock = readWriteLock.readLock(); private final Lock writeLock = readWriteLock.writeLock(); // 写入状态 public void writeStatus(int status) { writeLock.lock(); // 加写锁 try { this.status = status; } finally { writeLock.unlock(); } } // 读取状态 public int readState(int status) { readLock.lock(); // 加读锁 try { return status; } finally { readLock.unlock(); } } } StampedLock的使用方法与ReentrantReadWriteLock类似，只需要在进行读操作时，优先使用乐观读锁读取数据，并校验此过程中是否有写操作，如果校验成功，直接使用乐观锁的结果；反之，则获取悲观读锁再次读取数据，以避免脏读。\n四、总结 至此，有关Java锁的基础内容已经介绍完毕。前面首先介绍了锁在线程安全中的重要性，并列出了Java并发包中与锁的相互关系，随后分别介绍了具体的几个核心类：Lock与AQS是Java锁的抽象定义，而可重入锁与读写锁则是两种Java锁的具体实现。\n本文更偏向于基础概念的简介，源码的实现细节暂时没有涉及，由于理解有限，上述内容可能会有偏差，后续将按需修改或增加相关内容。\n同时，上述介绍的Java锁只适用于单机环境，分布式环境则使用分布式锁实现同步。有关分布式锁的内容，将在后续介绍。\n参考文档\n《深入理解Java虚拟机第3版 周志明 著》 《Java并发编程的艺术 方腾飞 魏鹏 程晓明 著》 廖雪峰的官方网站-多线程 ","wordCount":"3976","inLanguage":"zh","datePublished":"2022-07-06T11:15:36Z","dateModified":"2022-07-06T11:15:36Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://luanrz.github.io/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E9%94%81%E7%AE%80%E4%BB%8B/"},"publisher":{"@type":"Organization","name":"luanrz's blog","logo":{"@type":"ImageObject","url":"https://luanrz.github.io/images/icon.jpg"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://luanrz.github.io/ accesskey=h title="luanrz's blog (Alt + H)">luanrz's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://luanrz.github.io/ title=首页><span>首页</span></a></li><li><a href=https://luanrz.github.io/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://luanrz.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://luanrz.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://luanrz.github.io/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Java锁简介</h1><div class=post-meta><span title='2022-07-06 11:15:36 +0000 UTC'>2022-07-06</span>&nbsp;·&nbsp;<span>8 分钟</span>&nbsp;·&nbsp;<span>3976 字</span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e4%b8%80%e5%89%8d%e8%a8%80 aria-label=一、前言>一、前言</a></li><li><a href=#%e4%ba%8clock%e7%b1%bb%e4%b9%8b%e9%97%b4%e7%9a%84%e5%85%b3%e7%b3%bb aria-label=二、Lock类之间的关系>二、Lock类之间的关系</a></li><li><a href=#%e4%b8%89java%e9%94%81%e7%9a%84%e6%8a%bd%e8%b1%a1%e5%ae%9a%e4%b9%89 aria-label=三、Java锁的抽象定义>三、Java锁的抽象定义</a><ul><li><a href=#%e4%b8%80lock%e6%8e%a5%e5%8f%a3 aria-label=（一）Lock接口>（一）Lock接口</a></li><li><a href=#%e4%ba%8caqs%e7%b1%bb aria-label=（二）AQS类>（二）AQS类</a></li></ul></li><li><a href=#%e5%9b%9bjava%e9%94%81%e7%9a%84%e5%85%b7%e4%bd%93%e5%ae%9e%e7%8e%b0 aria-label=四、Java锁的具体实现>四、Java锁的具体实现</a><ul><li><a href=#%e4%b8%80%e5%8f%af%e9%87%8d%e5%85%a5%e9%94%81 aria-label=（一）可重入锁>（一）可重入锁</a></li><li><a href=#%e4%ba%8c%e8%af%bb%e5%86%99%e9%94%81 aria-label=（二）读写锁>（二）读写锁</a></li></ul></li><li><a href=#%e5%9b%9b%e6%80%bb%e7%bb%93 aria-label=四、总结>四、总结</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>Java锁(Lock)是实现Java线程安全的一种手段，它通过加锁和解锁的过程来实现线程间的同步，以保证多线程在竞争同一个公共资源时数据读写的正确性。</p><p>本文将首先阐明<a href=#%E4%B8%80%E5%89%8D%E8%A8%80>Lock在Java线程安全中的位置</a>，随后将简单介绍<a href=#%E4%BA%8Clock%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB><code>Lock</code>类之间的关系</a>，最后将简单介绍Java锁的<a href=#%E4%B8%89java%E9%94%81%E7%9A%84%E6%8A%BD%E8%B1%A1%E5%AE%9A%E4%B9%89>抽象定义</a>与<a href=#%E5%9B%9Bjava%E9%94%81%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0>具体实现</a>。</p><h2 id=一前言>一、前言<a hidden class=anchor aria-hidden=true href=#一前言>#</a></h2><p>保证Java线程安全有三种方式：阻塞(互斥)同步、非阻塞同步、无同步。本文将要介绍的锁(Lock)可以是阻塞同步(如：<code>ReentrantReadWriteLock</code>的写操作)，也可以是非阻塞同步(如：<code>StampedLock</code>的<code>tryOptimisticRead</code>读操作)，下面将简单介绍一下这三种方式。</p><p>互斥同步是<code>悲观锁</code>，悲观锁意味着“悲观地认为资源<strong>大概率会</strong>被同时访问，所以采取先加锁再操作数据的策略”，常见的实现方法是<code>synchronized</code>与部分<code>Lock</code>类，一般情况下，<code>Lock</code>与<code>synchronized</code>可以相互替换。</p><p>非阻塞同步是<code>乐观锁</code>，乐观锁意味着“乐观地认为资源<strong>大概率不会</strong>被同时访问，所以采取先操作数据再判断并发状态的策略”，常见的实现方法是<code>CAS</code>原子操作(如：<code>Atomic</code>系列类)。<code>乐观锁</code>虽然带有<code>锁</code>字，但其实并没有真正加锁与解锁的过程，只是用来和<code>悲观锁</code>加以区分，因此也可以将之称之为<code>无锁</code>同步。</p><p>除了互斥同步与非阻塞同步两种同步方案外，还有一种<code>无同步</code>方案，常见的实现方法是<code>ThreadLocal</code>与<code>volatile</code>等。</p><h2 id=二lock类之间的关系>二、Lock类之间的关系<a hidden class=anchor aria-hidden=true href=#二lock类之间的关系>#</a></h2><p>与Java锁相关的10个类都在<code>java.util.concurrent.locks</code>包下面，它们之间的关系如下所示：</p><pre tabindex=0><code class=language-plantuml data-lang=plantuml>@startuml Java锁类图

title Java锁类图

abstract class AbstractOwnableSynchronizer
abstract class AbstractQueuedSynchronizer #Pink
abstract class AbstractQueuedLongSynchronizer
interface Condition
interface Lock
class LockSupport
interface ReadWriteLock
class ReentrantLock #Pink
class ReentrantReadWriteLock #Pink
class StampedLock

Lock --|&gt; ReentrantLock
Lock --+ ReentrantReadWriteLock
Lock --+ StampedLock

ReentrantLock +-- AbstractQueuedSynchronizer
ReentrantReadWriteLock +-- AbstractQueuedSynchronizer
ReentrantReadWriteLock &lt;|-- ReadWriteLock

AbstractQueuedSynchronizer +-- Condition
AbstractQueuedSynchronizer --&gt; LockSupport

AbstractOwnableSynchronizer -|&gt; AbstractQueuedSynchronizer
AbstractOwnableSynchronizer --|&gt; AbstractQueuedLongSynchronizer

@enduml
</code></pre><p>上述大部分类都是在jdk5中新增的，其中<code>AbstractOwnableSynchronizer</code>与<code>AbstractQueuedLongSynchronizer</code>在jdk6中新增，<code>StampedLock</code>在jdk8中新增。</p><p><code>Lock</code>接口是锁的原型，队列同步器<code>AbstractQueuedSynchronizer</code>(<code>AQS</code>)是锁的实现基础，可重入锁<code>ReentrantLock</code>、读写锁<code>ReentrantReadWriteLock</code>与增强型读写锁<code>StampedLock</code>是锁的三种具体实现。</p><h2 id=三java锁的抽象定义>三、Java锁的抽象定义<a hidden class=anchor aria-hidden=true href=#三java锁的抽象定义>#</a></h2><p>Lock接口定义了锁的使用方法，AQS类定义了锁的实现规范。</p><h3 id=一lock接口>（一）Lock接口<a hidden class=anchor aria-hidden=true href=#一lock接口>#</a></h3><p>在jdk5之前，一般使用<code>synchronized</code>关键字实现同步，jdk5后，Lock也成为了一种更灵活的可选项。这里的Lock是广义的Lock，指的是<code>java.util.concurrent.locks</code>包的集合，狭义的<code>Lock</code>接口是这个集合中的一个元素，本小节介绍的是狭义的<code>Lock</code>接口。</p><blockquote><p>jdk后续版本，java团队从虚拟机层面对<code>synchronized</code>关键字做了一系列优化，如：适应性自旋、锁消除、锁膨胀、轻量级锁、偏向锁等。</p></blockquote><p>Lock接口有以下主要方法：</p><ul><li>lock：获取锁(加锁)</li><li>tryLock：尝试获取锁</li><li>unlock：释放锁</li></ul><p>下面罗列了jdk官方文档中两种使用锁的模板：</p><ol><li>使用<code>lock</code>与<code>unlock</code></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span>Lock lock <span style=color:#f92672>=</span> ...; <span style=color:#75715e>//定义并实例化锁</span>
</span></span><span style=display:flex><span>lock.<span style=color:#a6e22e>lock</span>(); <span style=color:#75715e>// 获取锁</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 操作被锁保护的资源</span>
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>    lock.<span style=color:#a6e22e>unlock</span>(); <span style=color:#75715e>// 释放锁</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=2><li>使用<code>tryLock</code>与<code>unlock</code></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span>Lock lock <span style=color:#f92672>=</span> ...; <span style=color:#75715e>//定义并实例化锁</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (lock.<span style=color:#a6e22e>tryLock</span>()) { <span style=color:#75715e>// 尝试获取锁：成功</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 操作被锁保护的资源</span>
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>        lock.<span style=color:#a6e22e>unlock</span>(); <span style=color:#75715e>// 释放锁</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>else</span> { <span style=color:#75715e>// 尝试获取锁：失败</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 执行其它流程</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=二aqs类>（二）AQS类<a hidden class=anchor aria-hidden=true href=#二aqs类>#</a></h3><p>队列同步器<code>AbstractQueuedSynchronizer</code>(<code>AQS</code>)是Java锁的基础，后续即将介绍的<a href=#%E5%9B%9Bjava%E9%94%81%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0>三种Java锁</a>都有对应的<code>AQS</code>内部类实现。</p><p><code>AQS</code>中有两个关键的数据元素：</p><ol><li>同步状态</li><li>同步队列</li></ol><p>其中，同步状态是一个<code>volatile int</code>类型的值，该值可以表示为持有锁的个数(如2表示持有2个锁，0表示不持有锁)。<code>AQS</code>使用<code>getState</code>、<code>setState</code>及<code>compareAndSetState</code>这三个方法来获取或修改state值。同时，同步队列是一个以自定义元素<code>Node</code>为节点的双向链表结构，该队列可以保存同步阻塞时的节点信息。</p><p><code>AQS</code>通过<code>acquire</code>及<code>release</code>系列方法来修改上述两个数据元素，来达到同步控制的目的。在这个过程中，有5个模板方法：<code>tryAcquire</code>、<code>tryRelease</code>、<code>tryAcquireShared</code>、<code>tryReleaseShared</code>、<code>isHeldExclusively</code>，它们默认会抛出<code>UnsupportedOperationException</code>异常，AQS的实现类需要去自定义它们的逻辑。</p><p>上面引出来了<code>AQS</code>中定义的一些关键方法，它们和<code>Lock</code>接口中的方法存在一定的依赖关系。从锁的使用到锁的实现，有以下两条调用链路：</p><ol><li>加锁：<code>Lock.lock()</code> &ndash;> <code>AQS.acquire()</code> &ndash;> <code>AQS.tryAcquire()</code> &ndash;> xxx</li><li>解锁：<code>Lock.unlock()</code> &ndash;> <code>AQS.release()</code> &ndash;> <code>AQS.tryRelease()</code> &ndash;> xxx</li></ol><p><code>Lock</code>实现类的加锁和解锁过程通过<code>AQS</code>类来实现，<code>Lock</code>与<code>AQS</code>共同组成了Java锁的抽象定义，为后面的<a href=#%E5%9B%9Bjava%E9%94%81%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0>Java锁的具体实现</a>做好了铺垫。</p><h2 id=四java锁的具体实现>四、Java锁的具体实现<a hidden class=anchor aria-hidden=true href=#四java锁的具体实现>#</a></h2><h3 id=一可重入锁>（一）可重入锁<a hidden class=anchor aria-hidden=true href=#一可重入锁>#</a></h3><p><code>ReentrantLock</code>是一个<strong>可重入</strong>的<strong>互斥</strong>锁，它与<code>synchronized</code>有相同的基础行为和语义，但比<code>synchronized</code>更有扩展性。</p><p>上面提到了两个概念，“互斥”与“可重入”，接下来将分别简单介绍这两个词的含义：</p><ul><li><p>互斥：<code>ReentrantLock</code>只能被一个线程所持有，当这个线程调用<code>lock</code>方法获得锁，并且没有调用<code>unlock</code>方法释放锁时，其它线程将无法获取该锁，只能处于等待状态。</p></li><li><p>可重入：持有锁的线程可以反复获得这个锁(比如在递归场景中)，这意味着当前线程可以重复进入被加锁的区域，而无需等待锁释放。每次执行<code>lock</code>方法都会导致同步状态<code>state</code>的值加1，执行<code>unlock</code>方法则会减1，<code>lock</code>与<code>unlock</code>成对生效时，才会最终释放当前线程的锁。</p></li></ul><p><code>ReentrantLock</code>通过构造函数中的<code>fair</code>来决定创建公平锁(FairSync)或非公平锁(NonfairSync)，默认为非公平锁。公平锁能够保证等待越久的线程越能优先获取到锁(通过<code>hasQueuedPredecessors</code>方法实现)，从而保证不同线程在获取锁阻塞时等待时间的公平性。一言以蔽之，<strong>非公平锁可以插队(不保证顺序)，而公平锁一般不能插队(保证FIFO的顺序)</strong></p><p>下面以一个简单的例子说明一下<code>ReentrantLock</code>的使用方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>StatusHolder</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> status;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Lock lock <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ReentrantLock();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 以传统的synchronized的方式同步修改状态</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>changeStatusWithSynchronized</span>(<span style=color:#66d9ef>int</span> status) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>synchronized</span> (<span style=color:#66d9ef>this</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>status</span> <span style=color:#f92672>=</span> status;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 以Lock.lock()的方式同步修改状态</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>changeStatusWithLock</span>(<span style=color:#66d9ef>int</span> status) {
</span></span><span style=display:flex><span>        lock.<span style=color:#a6e22e>lock</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>status</span> <span style=color:#f92672>=</span> status;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>            lock.<span style=color:#a6e22e>unlock</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 以Lock.tryLock()的方式同步修改状态</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>changeStatusWithTryLock</span>(<span style=color:#66d9ef>int</span> status) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (lock.<span style=color:#a6e22e>tryLock</span>()) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>status</span> <span style=color:#f92672>=</span> status;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>                lock.<span style=color:#a6e22e>unlock</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 获取锁失败，执行其它流程</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面使用三种方法来实现“修改状态”这一功能。作为对比，第一种使用的是传统的<code>synchronized</code>方式，第二种与第三种则是<code>ReentrantLock</code>的方式。<code>synchronized</code>与<code>ReentrantLock</code>在某些情况下可以互相替换，但<code>ReentrantLock</code>灵活度更高(比如可以实现超时等待)。</p><h3 id=二读写锁>（二）读写锁<a hidden class=anchor aria-hidden=true href=#二读写锁>#</a></h3><p><code>ReadWriteLock</code>接口维护了一对读锁和写锁。读锁可以被多个线程共享（非互斥），而写锁只能被一个线程持有（互斥）。这一特性也表明了<code>ReadWriteLock</code>更适合用于读多写少的场景。</p><p>根据读写锁的排列组合，有以下四种情况：</p><ol><li>一个线程持有<strong>读</strong>锁后，另一个线程尝试获取<strong>读</strong>锁</li><li>一个线程持有<strong>读</strong>锁后，另一个线程尝试获取<strong>写</strong>锁</li><li>一个线程持有<strong>写</strong>锁后，另一个线程尝试获取<strong>读</strong>锁</li><li>一个线程持有<strong>写</strong>锁后，另一个线程尝试获取<strong>写</strong>锁</li></ol><p><code>ReadWriteLock</code>中仅有第一个场景的同时读操作是共享的（这也是使用读写锁时大概率会发生的场景），其它三种情况一般情况下都是互斥的。</p><p><code>ReadWriteLock</code>当前有两个实现类：<code>ReentrantReadWriteLock</code>与<code>StampedLock</code>。<code>ReentrantReadWriteLock</code>是可重入的读写锁，它在读写锁的基础上支持重入操作。<code>StampedLock</code>是增强型的读写锁，它支持在读的过程中执行写操作（也即是上述排列组合的第2中情况），使用乐观读锁与悲观读锁的组合可以避免同时读写造成的脏读现象。同时，<code>StampedLock</code>是不可重入的。</p><p>接下来将以<code>ReentrantReadWriteLock</code>为例介绍读写锁的简单使用方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>StatusHolder</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> status;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> ReadWriteLock readWriteLock <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ReentrantReadWriteLock();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Lock readLock <span style=color:#f92672>=</span> readWriteLock.<span style=color:#a6e22e>readLock</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Lock writeLock <span style=color:#f92672>=</span> readWriteLock.<span style=color:#a6e22e>writeLock</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 写入状态</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>writeStatus</span>(<span style=color:#66d9ef>int</span> status) {
</span></span><span style=display:flex><span>        writeLock.<span style=color:#a6e22e>lock</span>(); <span style=color:#75715e>// 加写锁</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>status</span> <span style=color:#f92672>=</span> status;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>            writeLock.<span style=color:#a6e22e>unlock</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 读取状态</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>readState</span>(<span style=color:#66d9ef>int</span> status) {
</span></span><span style=display:flex><span>        readLock.<span style=color:#a6e22e>lock</span>(); <span style=color:#75715e>// 加读锁</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> status;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>            readLock.<span style=color:#a6e22e>unlock</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>StampedLock</code>的使用方法与<code>ReentrantReadWriteLock</code>类似，只需要在进行读操作时，优先使用乐观读锁读取数据，并校验此过程中是否有写操作，如果校验成功，直接使用乐观锁的结果；反之，则获取悲观读锁再次读取数据，以避免脏读。</p><h2 id=四总结>四、总结<a hidden class=anchor aria-hidden=true href=#四总结>#</a></h2><p>至此，有关Java锁的基础内容已经介绍完毕。前面首先介绍了锁在线程安全中的重要性，并列出了Java并发包中与锁的相互关系，随后分别介绍了具体的几个核心类：<code>Lock</code>与<code>AQS</code>是Java锁的抽象定义，而可重入锁与读写锁则是两种Java锁的具体实现。</p><p>本文更偏向于基础概念的简介，源码的实现细节暂时没有涉及，由于理解有限，上述内容可能会有偏差，后续将按需修改或增加相关内容。</p><p>同时，上述介绍的Java锁只适用于单机环境，分布式环境则使用分布式锁实现同步。有关分布式锁的内容，将在后续介绍。</p><blockquote><p>参考文档</p></blockquote><ol><li>《深入理解Java虚拟机第3版 周志明 著》</li><li>《Java并发编程的艺术 方腾飞 魏鹏 程晓明 著》</li><li><a href=https://www.liaoxuefeng.com/wiki/1252599548343744/1255943750561472>廖雪峰的官方网站-多线程</a></li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://luanrz.github.io/tags/java/>Java</a></li><li><a href=https://luanrz.github.io/tags/%E5%B9%B6%E5%8F%91/>并发</a></li></ul><nav class=paginav><a class=prev href=https://luanrz.github.io/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%AE%80%E4%BB%8B/><span class=title>« 上一页</span><br><span>Java阻塞队列简介</span>
</a><a class=next href=https://luanrz.github.io/posts/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91%E7%9A%844%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/><span class=title>下一页 »</span><br><span>远程开发的4种解决方案</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://luanrz.github.io/>luanrz's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>