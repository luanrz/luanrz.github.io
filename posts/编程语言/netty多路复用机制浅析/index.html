<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Netty多路复用机制浅析 | luanrz's blog</title><meta name=keywords content="Java,IO"><meta name=description content="一、操作系统中的多路复用IO模型
Java本身并不实现底层IO，而是通过native方法封装操作系统IO指令。
Linux(Unix)作为Java应用部署的主流操作系统，有五种IO模型："><meta name=author content><link rel=canonical href=https://luanrz.github.io/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/netty%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90/><link crossorigin=anonymous href=/assets/css/stylesheet.ed6c30fee125be816b653632a2732f92313b593583d98576c9eb2bf33a42b6e1.css integrity="sha256-7Www/uElvoFrZTYyonMvkjE7WTWD2YV2yesr8zpCtuE=" rel="preload stylesheet" as=style><link rel=icon href=https://luanrz.github.io/images/icon.jpg><link rel=icon type=image/png sizes=16x16 href=https://luanrz.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://luanrz.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://luanrz.github.io/apple-touch-icon.png><link rel=mask-icon href=https://luanrz.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://luanrz.github.io/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/netty%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script>const loadScript=(e,t)=>{var n=document.createElement("script");n.onerror=e=>{throw new URIError("The script "+e.target.src+" didn't load correctly.")},t&&(n.onload=t),document.head.insertAdjacentElement("beforeend",n),n.src=e},loadPlantUMLOnNeed=()=>{let e="language-plantuml";document.querySelectorAll("[class^="+e+"]").length>0&&loadScript("https://fastly.jsdelivr.net/gh/jmnote/plantuml-encoder@1.2.4/dist/plantuml-encoder.min.js",()=>{(function(){Array.prototype.forEach.call(document.querySelectorAll("[class^="+e+"]"),function(e){let t=document.createElement("IMG");t.loading="lazy",t.src="http://www.plantuml.com/plantuml/svg/~1"+plantumlEncoder.encode(e.innerText),e.parentNode.insertBefore(t,e),e.style.display="none"})})(),console.log("PlantUML init done")})};window.addEventListener("load",function(){loadPlantUMLOnNeed()})</script><meta property="og:url" content="https://luanrz.github.io/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/netty%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90/"><meta property="og:site_name" content="luanrz's blog"><meta property="og:title" content="Netty多路复用机制浅析"><meta property="og:description" content="一、操作系统中的多路复用IO模型 Java本身并不实现底层IO，而是通过native方法封装操作系统IO指令。
Linux(Unix)作为Java应用部署的主流操作系统，有五种IO模型："><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-05-30T14:21:28+08:00"><meta property="article:modified_time" content="2023-05-30T14:21:28+08:00"><meta property="article:tag" content="Java"><meta property="article:tag" content="IO"><meta name=twitter:card content="summary"><meta name=twitter:title content="Netty多路复用机制浅析"><meta name=twitter:description content="一、操作系统中的多路复用IO模型
Java本身并不实现底层IO，而是通过native方法封装操作系统IO指令。
Linux(Unix)作为Java应用部署的主流操作系统，有五种IO模型："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://luanrz.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Netty多路复用机制浅析","item":"https://luanrz.github.io/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/netty%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Netty多路复用机制浅析","name":"Netty多路复用机制浅析","description":"一、操作系统中的多路复用IO模型 Java本身并不实现底层IO，而是通过native方法封装操作系统IO指令。\nLinux(Unix)作为Java应用部署的主流操作系统，有五种IO模型：\n","keywords":["Java","IO"],"articleBody":"一、操作系统中的多路复用IO模型 Java本身并不实现底层IO，而是通过native方法封装操作系统IO指令。\nLinux(Unix)作为Java应用部署的主流操作系统，有五种IO模型：\n阻塞(blocking) IO 非阻塞(nonblocking) IO 多路复用(multiplexing) IO 信号驱动(signal driven) IO 异步(asynchronous) IO 其中，操作系统底层的多路复用IO是Java NIO与Netty实现请求多路复用的基础。\nLinux操作系统多路复用IO的主要实现方式有：select、poll、epoll等。\n在Linux的JDK8中，epoll是主要实现方式，poll则是作为epoll不可用时的备选（主要是用来兼容非SunOS与Linux的其它操作系统，详见Selector的初始化原理中的DefaultSelectorProvider类），select已被淘汰。在Liniux的JDK17中，epoll是唯一的实现方式。预计在后续的JDK版本中，epoll也将作为Linux平台支持多路复用IO的默认选项。\n二、Java原生NIO中的多路复用 Java中存在三种IO体系，分别是：BIO(OIO)、NIO、AIO，它们的名词解释如下：\nBIO = Blocking IO，阻塞式IO。OIO = Old Blocking IO，旧的阻塞式IO，与BIO等价。 NIO = Nonblocking IO = New IO，非阻塞式IO（新IO）。JDK1.4开始支持。 AIO = Asynchronous IO，异步IO。JDK1.7开始支持。 Java NIO通过java.nio.*下的Channel、Buffer、Selector等类，来支持高性能的请求多路复用。其中，Selector类是实现多路复用IO的关键。\n虽然NIO又被称之为非阻塞式IO，但是需要注意的是，NIO和Linux(Unix)五种IO模型中的非阻塞IO不是同一个东西，NIO的底层实现更偏向于IO模型中的多路复用IO。\n（一）Selector的初始化 Selector类的初始化很简单，只需一行代码，如下：\nSelector selector = Selector.open(); 其内部细节详见Selector的初始化原理。\n（二）Selector的使用 Selector的相关API有：\nSelectableChannel.register()：Selector注册 Selector.selectedKeys()：获取Selector中所有的事件 SelectionKey.isXXX()：判断事件的状态 一个Selector类的使用代码片段如下：\nwhile (true) { Set\u003cSelectionKey\u003e selectionKeys = selector.selectedKeys(); Iterator\u003cSelectionKey\u003e iterator = selectionKeys.iterator(); while (iterator.hasNext()) { SelectionKey selectionKey = iterator.next(); if (selectionKey.isAcceptable()) { ServerSocketChannel serverSocketChannel = (ServerSocketChannel) selectionKey.channel(); SocketChannel socketChannel = serverSocketChannel.accept(); socketChannel.configureBlocking(false); socketChannel.register(selector, SelectionKey.OP_READ); } else if(selectionKey.isReadable()) { SocketChannel socketChannel = (SocketChannel) selectionKey.channel(); System.out.println(readDataFromSocketChannel(socketChannel)); socketChannel.close(); } iterator.remove(); } } （三）Selector的初始化原理 下述代码以JDK8为例，JDK17及后续版本有所不同。\n进入Selector的open()方法中：\npublic abstract class Selector implements Closeable { public static Selector open() throws IOException { return SelectorProvider.provider().openSelector(); } } Selector是通过SelectorProvider创建出来的，SelectorProvider的provider()如下所示：\npublic abstract class SelectorProvider { public static SelectorProvider provider() { synchronized (lock) { if (provider != null) return provider; return AccessController.doPrivileged( new PrivilegedAction\u003cSelectorProvider\u003e() { public SelectorProvider run() { if (loadProviderFromProperty()) return provider; if (loadProviderAsService()) return provider; provider = sun.nio.ch.DefaultSelectorProvider.create(); return provider; } }); } } } 如上述代码所示，将依次从以下位置获取SelectorProvider实例：\n系统属性 SPI机制（ServiceLoader） 默认的DefaultSelectorProvider。 下面进入DefaultSelectorProvider的create()方法，如下所示：\npublic class DefaultSelectorProvider { public static SelectorProvider create() { String osname = AccessController.doPrivileged(new GetPropertyAction(\"os.name\")); if (osname.equals(\"SunOS\")) return createProvider(\"sun.nio.ch.DevPollSelectorProvider\"); if (osname.equals(\"Linux\")) return createProvider(\"sun.nio.ch.EPollSelectorProvider\"); return new sun.nio.ch.PollSelectorProvider(); } } 如上所示，在Linux系统中，SelectorProvider会默认实例化为EPollSelectorProvider。EPollSelectorProvider中的openSelector()方法会创建一个类型为EPollSelectorImpl的Selector实例，如下所示：\npublic class EPollSelectorProvider extends SelectorProviderImpl { public AbstractSelector openSelector() throws IOException { return new EPollSelectorImpl(this); } } 见名知意，EPollSelectorProvider底层使用epoll来实现多路复用IO。\n三、Netty中的多路复用 Netty同样基于Selector类完成请求的多路复用。\n（一）Netty中Selector的初始化 Netty在创建NioEventLoopGroup的过程中，其构造函数会调用SelectorProvider.provider()创建SelectorProvider实例，如下所示：\npublic class NioEventLoopGroup extends MultithreadEventLoopGroup { public NioEventLoopGroup(int nThreads, Executor executor) { this(nThreads, executor, SelectorProvider.provider()); } } SelectorProvider.provider()的过程与NIO中Selector的初始化原理完全一样。\nNioEventLoopGroup后续创建对应的NioEventLoop实例时，会将SelectorProvider作为构造方法属性传递下去，如下所示：\npublic class NioEventLoopGroup extends MultithreadEventLoopGroup { @Override protected EventLoop newChild(Executor executor, Object... args) throws Exception { // 获取SelectorProvider SelectorProvider selectorProvider = (SelectorProvider) args[0]; // ...其它逻辑 // 创建新的NioEventLoop，将SelectorProvider作为构造方法函数传递给NioEventLoop return new NioEventLoop(this, executor, selectorProvider, selectStrategyFactory.newSelectStrategy(), rejectedExecutionHandler, taskQueueFactory, tailTaskQueueFactory); } } NioEventLoop的构造方法如下：\npublic final class NioEventLoop extends SingleThreadEventLoop { private Selector selector; private Selector unwrappedSelector; private SelectedSelectionKeySet selectedKeys; NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider, SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler, EventLoopTaskQueueFactory taskQueueFactory, EventLoopTaskQueueFactory tailTaskQueueFactory) { super(parent, executor, false, newTaskQueue(taskQueueFactory), newTaskQueue(tailTaskQueueFactory), rejectedExecutionHandler); this.provider = ObjectUtil.checkNotNull(selectorProvider, \"selectorProvider\"); this.selectStrategy = ObjectUtil.checkNotNull(strategy, \"selectStrategy\"); // 创建Selector元祖，其中包含selector与unwrappedSelector final SelectorTuple selectorTuple = openSelector(); this.selector = selectorTuple.selector; this.unwrappedSelector = selectorTuple.unwrappedSelector; } } 至此，NioEventLoop中的Selector创建完成。上述openSelector()方法内部对Selector做了优化，有关优化细节详见Netty中Selector的优化。\n（二）Netty中Selector的优化 Netty中的NioEventLoop在创建Selector时，会根据DISABLE_KEY_SET_OPTIMIZATION属性判断是否需要优化Selector，详见NioEventLoop的openSelector()方法：\npublic final class NioEventLoop extends SingleThreadEventLoop { private SelectorTuple openSelector() { final Selector unwrappedSelector; try { unwrappedSelector = provider.openSelector(); } catch (IOException e) { throw new ChannelException(\"failed to open a new selector\", e); } if (DISABLE_KEY_SET_OPTIMIZATION) { // 如果禁用优化，不对selector做任何优化处理 return new SelectorTuple(unwrappedSelector); } // 通过反射拿到SelectorImpl类 Object maybeSelectorImplClass = AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() { @Override public Object run() { try { return Class.forName( \"sun.nio.ch.SelectorImpl\", false, PlatformDependent.getSystemClassLoader()); } catch (Throwable cause) { return cause; } } }); final Class\u003c?\u003e selectorImplClass = (Class\u003c?\u003e) maybeSelectorImplClass; final SelectedSelectionKeySet selectedKeySet = new SelectedSelectionKeySet(); Object maybeException = AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() { @Override public Object run() { Field selectedKeysField = selectorImplClass.getDeclaredField(\"selectedKeys\"); Field publicSelectedKeysField = selectorImplClass.getDeclaredField(\"publicSelectedKeys\"); // 通过反射重置selectedKeys与publicSelectedKeys selectedKeysField.set(unwrappedSelector, selectedKeySet); publicSelectedKeysField.set(unwrappedSelector, selectedKeySet); return null; } }); selectedKeys = selectedKeySet; // 将selector实例化为SelectedSelectionKeySetSelector return new SelectorTuple(unwrappedSelector, new SelectedSelectionKeySetSelector(unwrappedSelector, selectedKeySet)); } } 在开启优化后（默认开启），上述代码主要做了两件事：\n将selector中的publicKeys与publicSelectedKeys的HashMap通过反射的方式替换为自定义的SelectedSelectionKeySet(即selectedKeys属性)。该Set重写优化了Set的add()、iterator()、reset()等方法。 将selector本身实例化为SelectedSelectionKeySetSelector。该Selector中有一个原始unwrappedSelector的委托属性，大部分方法依旧调用委托实例中的方法，但针对selectNow()与select()方法，则重写优化，改为调用上述SelectedSelectionKeySet中的reset()方法。 （三）Netty中Selector的执行 在执行NioEventLoop的run()后，会调用processSelectedKeys()，该方法是处理IO事件的核心，如下：\npublic final class NioEventLoop extends SingleThreadEventLoop { private void processSelectedKeys() { if (selectedKeys != null) { processSelectedKeysOptimized(); } else { processSelectedKeysPlain(selector.selectedKeys()); } } } 由于默认开启了优化，在openSelector()中一定为selectedKeys赋了值（详见Netty中Selector的优化），因此会走到processSelectedKeysOptimized()，processSelectedKeysOptimized则会根据优化后的selectedKeys执行后续的processSelectedKey()。有关后续更多细节，可进一步阅读源码。\n四、总结 Linux操作系统的五种IO模型中的多路复用IO模型是后续NIO和Netty实现请求复用的基础，其实现方式主要是epoll。\nJava原生NIO中实现多路复用的关键组件是Channel、Buffer、Selector等类。Selector封装了操作系统底层的epoll指令来实现IO多路复用。\nNetty同样采用了Java原生NIO的Selector组件来实现多路复用，只不过在其基础上做了部分优化。\n参考文档\nUnix IO 模型 Netty官网 Netty(二)：io请求处理过程解析 netty系列之:NIO和netty详解 ","wordCount":"3522","inLanguage":"zh","datePublished":"2023-05-30T14:21:28+08:00","dateModified":"2023-05-30T14:21:28+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://luanrz.github.io/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/netty%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90/"},"publisher":{"@type":"Organization","name":"luanrz's blog","logo":{"@type":"ImageObject","url":"https://luanrz.github.io/images/icon.jpg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://luanrz.github.io/ accesskey=h title="luanrz's blog (Alt + H)">luanrz's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://luanrz.github.io/ title=首页><span>首页</span></a></li><li><a href=https://luanrz.github.io/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://luanrz.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://luanrz.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://luanrz.github.io/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Netty多路复用机制浅析</h1><div class=post-meta><span title='2023-05-30 14:21:28 +0800 +0800'>2023-05-30</span>&nbsp;·&nbsp;8 分钟&nbsp;·&nbsp;3522 字</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e4%b8%80%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e4%b8%ad%e7%9a%84%e5%a4%9a%e8%b7%af%e5%a4%8d%e7%94%a8io%e6%a8%a1%e5%9e%8b aria-label=一、操作系统中的多路复用IO模型>一、操作系统中的多路复用IO模型</a></li><li><a href=#%e4%ba%8cjava%e5%8e%9f%e7%94%9fnio%e4%b8%ad%e7%9a%84%e5%a4%9a%e8%b7%af%e5%a4%8d%e7%94%a8 aria-label=二、Java原生NIO中的多路复用>二、Java原生NIO中的多路复用</a><ul><li><a href=#%e4%b8%80selector%e7%9a%84%e5%88%9d%e5%a7%8b%e5%8c%96 aria-label=（一）Selector的初始化>（一）Selector的初始化</a></li><li><a href=#%e4%ba%8cselector%e7%9a%84%e4%bd%bf%e7%94%a8 aria-label=（二）Selector的使用>（二）Selector的使用</a></li><li><a href=#%e4%b8%89selector%e7%9a%84%e5%88%9d%e5%a7%8b%e5%8c%96%e5%8e%9f%e7%90%86 aria-label=（三）Selector的初始化原理>（三）Selector的初始化原理</a></li></ul></li><li><a href=#%e4%b8%89netty%e4%b8%ad%e7%9a%84%e5%a4%9a%e8%b7%af%e5%a4%8d%e7%94%a8 aria-label=三、Netty中的多路复用>三、Netty中的多路复用</a><ul><li><a href=#%e4%b8%80netty%e4%b8%adselector%e7%9a%84%e5%88%9d%e5%a7%8b%e5%8c%96 aria-label=（一）Netty中Selector的初始化>（一）Netty中Selector的初始化</a></li><li><a href=#%e4%ba%8cnetty%e4%b8%adselector%e7%9a%84%e4%bc%98%e5%8c%96 aria-label=（二）Netty中Selector的优化>（二）Netty中Selector的优化</a></li><li><a href=#%e4%b8%89netty%e4%b8%adselector%e7%9a%84%e6%89%a7%e8%a1%8c aria-label=（三）Netty中Selector的执行>（三）Netty中Selector的执行</a></li></ul></li><li><a href=#%e5%9b%9b%e6%80%bb%e7%bb%93 aria-label=四、总结>四、总结</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement||=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e}),elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=一操作系统中的多路复用io模型>一、操作系统中的多路复用IO模型<a hidden class=anchor aria-hidden=true href=#一操作系统中的多路复用io模型>#</a></h2><p>Java本身并不实现底层IO，而是通过native方法封装操作系统IO指令。</p><p>Linux(Unix)作为Java应用部署的主流操作系统，有五种IO模型：</p><ul><li>阻塞(blocking) IO</li><li>非阻塞(nonblocking) IO</li><li>多路复用(multiplexing) IO</li><li>信号驱动(signal driven) IO</li><li>异步(asynchronous) IO</li></ul><p>其中，操作系统底层的多路复用IO是Java NIO与Netty实现请求多路复用的基础。</p><p>Linux操作系统多路复用IO的主要实现方式有：<code>select</code>、<code>poll</code>、<code>epoll</code>等。</p><p>在Linux的JDK8中，<code>epoll</code>是主要实现方式，<code>poll</code>则是作为<code>epoll</code>不可用时的备选（主要是用来兼容非SunOS与Linux的其它操作系统，详见<a href=#%E4%B8%89selector%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8E%9F%E7%90%86>Selector的初始化原理</a>中的<code>DefaultSelectorProvider</code>类），<code>select</code>已被淘汰。在Liniux的JDK17中，<code>epoll</code>是唯一的实现方式。预计在后续的JDK版本中，<code>epoll</code>也将作为Linux平台支持多路复用IO的默认选项。</p><h2 id=二java原生nio中的多路复用>二、Java原生NIO中的多路复用<a hidden class=anchor aria-hidden=true href=#二java原生nio中的多路复用>#</a></h2><p>Java中存在三种IO体系，分别是：BIO(OIO)、NIO、AIO，它们的名词解释如下：</p><ul><li>BIO = Blocking IO，阻塞式IO。OIO = Old Blocking IO，旧的阻塞式IO，与BIO等价。</li><li>NIO = Nonblocking IO = New IO，非阻塞式IO（新IO）。JDK1.4开始支持。</li><li>AIO = Asynchronous IO，异步IO。JDK1.7开始支持。</li></ul><p>Java NIO通过<code>java.nio.*</code>下的<code>Channel</code>、<code>Buffer</code>、<code>Selector</code>等类，来支持高性能的请求多路复用。其中，<code>Selector</code>类是实现多路复用IO的关键。</p><blockquote><p>虽然NIO又被称之为非阻塞式IO，但是需要注意的是，NIO和Linux(Unix)五种IO模型中的非阻塞IO不是同一个东西，NIO的底层实现更偏向于IO模型中的多路复用IO。</p></blockquote><h3 id=一selector的初始化>（一）Selector的初始化<a hidden class=anchor aria-hidden=true href=#一selector的初始化>#</a></h3><p><code>Selector</code>类的初始化很简单，只需一行代码，如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Selector selector <span style=color:#f92672>=</span> Selector.<span style=color:#a6e22e>open</span>();
</span></span></code></pre></div><p>其内部细节详见<a href=#%E4%B8%89selector%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8E%9F%E7%90%86>Selector的初始化原理</a>。</p><h3 id=二selector的使用>（二）Selector的使用<a hidden class=anchor aria-hidden=true href=#二selector的使用>#</a></h3><p>Selector的相关API有：</p><ul><li><code>SelectableChannel.register()</code>：Selector注册</li><li><code>Selector.selectedKeys()</code>：获取Selector中所有的事件</li><li><code>SelectionKey.isXXX()</code>：判断事件的状态</li></ul><p>一个<code>Selector</code>类的使用代码片段如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>    Set<span style=color:#f92672>&lt;</span>SelectionKey<span style=color:#f92672>&gt;</span> selectionKeys <span style=color:#f92672>=</span> selector.<span style=color:#a6e22e>selectedKeys</span>();
</span></span><span style=display:flex><span>    Iterator<span style=color:#f92672>&lt;</span>SelectionKey<span style=color:#f92672>&gt;</span> iterator <span style=color:#f92672>=</span> selectionKeys.<span style=color:#a6e22e>iterator</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (iterator.<span style=color:#a6e22e>hasNext</span>()) {
</span></span><span style=display:flex><span>        SelectionKey selectionKey <span style=color:#f92672>=</span> iterator.<span style=color:#a6e22e>next</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (selectionKey.<span style=color:#a6e22e>isAcceptable</span>()) {
</span></span><span style=display:flex><span>            ServerSocketChannel serverSocketChannel <span style=color:#f92672>=</span> (ServerSocketChannel) selectionKey.<span style=color:#a6e22e>channel</span>();
</span></span><span style=display:flex><span>            SocketChannel socketChannel <span style=color:#f92672>=</span> serverSocketChannel.<span style=color:#a6e22e>accept</span>();
</span></span><span style=display:flex><span>            socketChannel.<span style=color:#a6e22e>configureBlocking</span>(<span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>            socketChannel.<span style=color:#a6e22e>register</span>(selector, SelectionKey.<span style=color:#a6e22e>OP_READ</span>);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span>(selectionKey.<span style=color:#a6e22e>isReadable</span>()) {
</span></span><span style=display:flex><span>            SocketChannel socketChannel <span style=color:#f92672>=</span> (SocketChannel) selectionKey.<span style=color:#a6e22e>channel</span>();
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(readDataFromSocketChannel(socketChannel));
</span></span><span style=display:flex><span>            socketChannel.<span style=color:#a6e22e>close</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        iterator.<span style=color:#a6e22e>remove</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=三selector的初始化原理>（三）Selector的初始化原理<a hidden class=anchor aria-hidden=true href=#三selector的初始化原理>#</a></h3><blockquote><p>下述代码以JDK8为例，JDK17及后续版本有所不同。</p></blockquote><p>进入<code>Selector</code>的<code>open()</code>方法中：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Selector</span> <span style=color:#66d9ef>implements</span> Closeable {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> Selector <span style=color:#a6e22e>open</span>() <span style=color:#66d9ef>throws</span> IOException {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> SelectorProvider.<span style=color:#a6e22e>provider</span>().<span style=color:#a6e22e>openSelector</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>Selector</code>是通过<code>SelectorProvider</code>创建出来的，<code>SelectorProvider</code>的<code>provider()</code>如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SelectorProvider</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> SelectorProvider <span style=color:#a6e22e>provider</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>synchronized</span> (lock) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (provider <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> provider;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> AccessController.<span style=color:#a6e22e>doPrivileged</span>(
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>new</span> PrivilegedAction<span style=color:#f92672>&lt;</span>SelectorProvider<span style=color:#f92672>&gt;</span>() {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>public</span> SelectorProvider <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> (loadProviderFromProperty())
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>return</span> provider;
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> (loadProviderAsService())
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>return</span> provider;
</span></span><span style=display:flex><span>                        provider <span style=color:#f92672>=</span> sun.<span style=color:#a6e22e>nio</span>.<span style=color:#a6e22e>ch</span>.<span style=color:#a6e22e>DefaultSelectorProvider</span>.<span style=color:#a6e22e>create</span>();
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span> provider;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                });
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如上述代码所示，将依次从以下位置获取SelectorProvider实例：</p><ul><li>系统属性</li><li>SPI机制（ServiceLoader）</li><li>默认的<code>DefaultSelectorProvider</code>。</li></ul><p>下面进入<code>DefaultSelectorProvider</code>的<code>create()</code>方法，如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DefaultSelectorProvider</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> SelectorProvider <span style=color:#a6e22e>create</span>() {
</span></span><span style=display:flex><span>        String osname <span style=color:#f92672>=</span> AccessController.<span style=color:#a6e22e>doPrivileged</span>(<span style=color:#66d9ef>new</span> GetPropertyAction(<span style=color:#e6db74>&#34;os.name&#34;</span>));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (osname.<span style=color:#a6e22e>equals</span>(<span style=color:#e6db74>&#34;SunOS&#34;</span>))
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> createProvider(<span style=color:#e6db74>&#34;sun.nio.ch.DevPollSelectorProvider&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (osname.<span style=color:#a6e22e>equals</span>(<span style=color:#e6db74>&#34;Linux&#34;</span>))
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> createProvider(<span style=color:#e6db74>&#34;sun.nio.ch.EPollSelectorProvider&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> sun.<span style=color:#a6e22e>nio</span>.<span style=color:#a6e22e>ch</span>.<span style=color:#a6e22e>PollSelectorProvider</span>();
</span></span><span style=display:flex><span>    }    
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如上所示，在Linux系统中，<code>SelectorProvider</code>会默认实例化为<code>EPollSelectorProvider</code>。<code>EPollSelectorProvider</code>中的<code>openSelector()</code>方法会创建一个类型为<code>EPollSelectorImpl</code>的<code>Selector</code>实例，如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>EPollSelectorProvider</span> <span style=color:#66d9ef>extends</span> SelectorProviderImpl {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> AbstractSelector <span style=color:#a6e22e>openSelector</span>() <span style=color:#66d9ef>throws</span> IOException {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> EPollSelectorImpl(<span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>见名知意，<code>EPollSelectorProvider</code>底层使用<code>epoll</code>来实现多路复用IO。</p><h2 id=三netty中的多路复用>三、Netty中的多路复用<a hidden class=anchor aria-hidden=true href=#三netty中的多路复用>#</a></h2><p>Netty同样基于<code>Selector</code>类完成请求的多路复用。</p><h3 id=一netty中selector的初始化>（一）Netty中Selector的初始化<a hidden class=anchor aria-hidden=true href=#一netty中selector的初始化>#</a></h3><p>Netty在创建<code>NioEventLoopGroup</code>的过程中，其构造函数会调用<code>SelectorProvider.provider()</code>创建<code>SelectorProvider</code>实例，如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NioEventLoopGroup</span> <span style=color:#66d9ef>extends</span> MultithreadEventLoopGroup {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>NioEventLoopGroup</span>(<span style=color:#66d9ef>int</span> nThreads, Executor executor) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>(nThreads, executor, SelectorProvider.<span style=color:#a6e22e>provider</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>SelectorProvider.provider()的过程与NIO中<a href=#%E4%B8%89selector%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8E%9F%E7%90%86>Selector的初始化原理</a>完全一样。</p></blockquote><p><code>NioEventLoopGroup</code>后续创建对应的<code>NioEventLoop</code>实例时，会将<code>SelectorProvider</code>作为构造方法属性传递下去，如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NioEventLoopGroup</span> <span style=color:#66d9ef>extends</span> MultithreadEventLoopGroup {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> EventLoop <span style=color:#a6e22e>newChild</span>(Executor executor, Object... args) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 获取SelectorProvider</span>
</span></span><span style=display:flex><span>        SelectorProvider selectorProvider <span style=color:#f92672>=</span> (SelectorProvider) args<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...其它逻辑</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建新的NioEventLoop，将SelectorProvider作为构造方法函数传递给NioEventLoop</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> NioEventLoop(<span style=color:#66d9ef>this</span>, executor, selectorProvider,
</span></span><span style=display:flex><span>                selectStrategyFactory.<span style=color:#a6e22e>newSelectStrategy</span>(),
</span></span><span style=display:flex><span>                rejectedExecutionHandler, taskQueueFactory, tailTaskQueueFactory);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>NioEventLoop的构造方法如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NioEventLoop</span> <span style=color:#66d9ef>extends</span> SingleThreadEventLoop {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Selector selector;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Selector unwrappedSelector;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> SelectedSelectionKeySet selectedKeys;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider,
</span></span><span style=display:flex><span>                 SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler,
</span></span><span style=display:flex><span>                 EventLoopTaskQueueFactory taskQueueFactory, EventLoopTaskQueueFactory tailTaskQueueFactory) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>(parent, executor, <span style=color:#66d9ef>false</span>, newTaskQueue(taskQueueFactory), newTaskQueue(tailTaskQueueFactory),
</span></span><span style=display:flex><span>                rejectedExecutionHandler);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>provider</span> <span style=color:#f92672>=</span> ObjectUtil.<span style=color:#a6e22e>checkNotNull</span>(selectorProvider, <span style=color:#e6db74>&#34;selectorProvider&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>selectStrategy</span> <span style=color:#f92672>=</span> ObjectUtil.<span style=color:#a6e22e>checkNotNull</span>(strategy, <span style=color:#e6db74>&#34;selectStrategy&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建Selector元祖，其中包含selector与unwrappedSelector</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> SelectorTuple selectorTuple <span style=color:#f92672>=</span> openSelector();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>selector</span> <span style=color:#f92672>=</span> selectorTuple.<span style=color:#a6e22e>selector</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>unwrappedSelector</span> <span style=color:#f92672>=</span> selectorTuple.<span style=color:#a6e22e>unwrappedSelector</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>至此，<code>NioEventLoop</code>中的<code>Selector</code>创建完成。上述<code>openSelector()</code>方法内部对<code>Selector</code>做了优化，有关优化细节详见<a href=#%E4%BA%8Cnetty%E4%B8%ADselector%E7%9A%84%E4%BC%98%E5%8C%96>Netty中Selector的优化</a>。</p><h3 id=二netty中selector的优化>（二）Netty中Selector的优化<a hidden class=anchor aria-hidden=true href=#二netty中selector的优化>#</a></h3><p>Netty中的<code>NioEventLoop</code>在创建<code>Selector</code>时，会根据<code>DISABLE_KEY_SET_OPTIMIZATION</code>属性判断是否需要优化<code>Selector</code>，详见<code>NioEventLoop</code>的<code>openSelector()</code>方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NioEventLoop</span> <span style=color:#66d9ef>extends</span> SingleThreadEventLoop {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> SelectorTuple <span style=color:#a6e22e>openSelector</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> Selector unwrappedSelector;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            unwrappedSelector <span style=color:#f92672>=</span> provider.<span style=color:#a6e22e>openSelector</span>();
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (IOException e) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> ChannelException(<span style=color:#e6db74>&#34;failed to open a new selector&#34;</span>, e);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (DISABLE_KEY_SET_OPTIMIZATION) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 如果禁用优化，不对selector做任何优化处理</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> SelectorTuple(unwrappedSelector);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 通过反射拿到SelectorImpl类</span>
</span></span><span style=display:flex><span>        Object maybeSelectorImplClass <span style=color:#f92672>=</span> AccessController.<span style=color:#a6e22e>doPrivileged</span>(<span style=color:#66d9ef>new</span> PrivilegedAction<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&gt;</span>() {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> Object <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> Class.<span style=color:#a6e22e>forName</span>(
</span></span><span style=display:flex><span>                            <span style=color:#e6db74>&#34;sun.nio.ch.SelectorImpl&#34;</span>,
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>false</span>,
</span></span><span style=display:flex><span>                            PlatformDependent.<span style=color:#a6e22e>getSystemClassLoader</span>());
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>catch</span> (Throwable cause) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> cause;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> Class<span style=color:#f92672>&lt;?&gt;</span> selectorImplClass <span style=color:#f92672>=</span> (Class<span style=color:#f92672>&lt;?&gt;</span>) maybeSelectorImplClass;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> SelectedSelectionKeySet selectedKeySet <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SelectedSelectionKeySet();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Object maybeException <span style=color:#f92672>=</span> AccessController.<span style=color:#a6e22e>doPrivileged</span>(<span style=color:#66d9ef>new</span> PrivilegedAction<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&gt;</span>() {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> Object <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>                Field selectedKeysField <span style=color:#f92672>=</span> selectorImplClass.<span style=color:#a6e22e>getDeclaredField</span>(<span style=color:#e6db74>&#34;selectedKeys&#34;</span>);
</span></span><span style=display:flex><span>                Field publicSelectedKeysField <span style=color:#f92672>=</span> selectorImplClass.<span style=color:#a6e22e>getDeclaredField</span>(<span style=color:#e6db74>&#34;publicSelectedKeys&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 通过反射重置selectedKeys与publicSelectedKeys</span>
</span></span><span style=display:flex><span>                selectedKeysField.<span style=color:#a6e22e>set</span>(unwrappedSelector, selectedKeySet);
</span></span><span style=display:flex><span>                publicSelectedKeysField.<span style=color:#a6e22e>set</span>(unwrappedSelector, selectedKeySet);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        selectedKeys <span style=color:#f92672>=</span> selectedKeySet;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 将selector实例化为SelectedSelectionKeySetSelector</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> SelectorTuple(unwrappedSelector,
</span></span><span style=display:flex><span>                                 <span style=color:#66d9ef>new</span> SelectedSelectionKeySetSelector(unwrappedSelector, selectedKeySet));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在开启优化后（默认开启），上述代码主要做了两件事：</p><ul><li>将<code>selector</code>中的<code>publicKeys</code>与<code>publicSelectedKeys</code>的<code>HashMap</code>通过反射的方式替换为自定义的<code>SelectedSelectionKeySet</code>(即<code>selectedKeys</code>属性)。该Set重写优化了<code>Set</code>的<code>add()</code>、<code>iterator()</code>、<code>reset()</code>等方法。</li><li>将<code>selector</code>本身实例化为<code>SelectedSelectionKeySetSelector</code>。该Selector中有一个原始<code>unwrappedSelector</code>的委托属性，大部分方法依旧调用委托实例中的方法，但针对<code>selectNow()</code>与<code>select()</code>方法，则重写优化，改为调用上述<code>SelectedSelectionKeySet</code>中的<code>reset()</code>方法。</li></ul><h3 id=三netty中selector的执行>（三）Netty中Selector的执行<a hidden class=anchor aria-hidden=true href=#三netty中selector的执行>#</a></h3><p>在执行<code>NioEventLoop</code>的<code>run()</code>后，会调用<code>processSelectedKeys()</code>，该方法是处理IO事件的核心，如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NioEventLoop</span> <span style=color:#66d9ef>extends</span> SingleThreadEventLoop {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>processSelectedKeys</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (selectedKeys <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            processSelectedKeysOptimized();
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            processSelectedKeysPlain(selector.<span style=color:#a6e22e>selectedKeys</span>());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>由于默认开启了优化，在<code>openSelector()</code>中一定为selectedKeys赋了值（详见<a href=#%E4%BA%8Cnetty%E4%B8%ADselector%E7%9A%84%E4%BC%98%E5%8C%96>Netty中Selector的优化</a>），因此会走到<code>processSelectedKeysOptimized()</code>，<code>processSelectedKeysOptimized</code>则会根据优化后的<code>selectedKeys</code>执行后续的<code>processSelectedKey()</code>。有关后续更多细节，可进一步阅读源码。</p><h2 id=四总结>四、总结<a hidden class=anchor aria-hidden=true href=#四总结>#</a></h2><p>Linux操作系统的五种IO模型中的多路复用IO模型是后续NIO和Netty实现请求复用的基础，其实现方式主要是<code>epoll</code>。</p><p>Java原生NIO中实现多路复用的关键组件是<code>Channel</code>、<code>Buffer</code>、<code>Selector</code>等类。<code>Selector</code>封装了操作系统底层的<code>epoll</code>指令来实现IO多路复用。</p><p>Netty同样采用了Java原生NIO的<code>Selector</code>组件来实现多路复用，只不过在其基础上做了部分优化。</p><blockquote><p>参考文档</p></blockquote><ol><li><a href=https://pdai.tech/md/java/io/java-io-model.html>Unix IO 模型</a></li><li><a href=https://netty.io/index.html>Netty官网</a></li><li><a href=https://www.cnblogs.com/yougewe/p/13418559.html>Netty(二)：io请求处理过程解析</a></li><li><a href=https://juejin.cn/post/7068132307701334047>netty系列之:NIO和netty详解</a></li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://luanrz.github.io/tags/java/>Java</a></li><li><a href=https://luanrz.github.io/tags/io/>IO</a></li></ul><nav class=paginav><a class=prev href=https://luanrz.github.io/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/helm%E9%83%A8%E7%BD%B2k8s%E6%97%B6secret%E5%A4%A7%E5%B0%8F%E8%B6%85%E8%BF%871mb%E7%9A%84%E9%97%AE%E9%A2%98/><span class=title>« 上一页</span><br><span>Helm部署K8S时Secret大小超过1MB的问题</span>
</a><a class=next href=https://luanrz.github.io/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E4%BB%8E%E5%A4%96%E9%83%A8%E8%8E%B7%E5%8F%96java%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%9F%BA%E4%BA%8E%E5%8F%8D%E5%B0%84%E4%B8%8E%E5%88%87%E9%9D%A2%E7%9A%84%E4%B8%80%E7%A7%8D%E5%AE%9E%E7%8E%B0/><span class=title>下一页 »</span><br><span>从外部获取Java局部变量：基于反射与切面的一种实现</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://luanrz.github.io/>luanrz's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>