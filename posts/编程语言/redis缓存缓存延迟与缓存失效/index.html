<!doctype html><html lang=zh dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Redis缓存：缓存延迟与缓存失效 | luanrz's blog</title><meta name=keywords content="Redis"><meta name=description content="Redis缓存延迟指的是：Redis与数据库发生同步过程中Redis数据状态滞后的现象。缓存延迟涉及到数据一致性与缓存更新策略的选择。
Redis缓存失效指的是：因为缓存穿透、缓存击穿、缓存雪崩等原因导致Redis缓存查询不到的情况。"><meta name=author content><link rel=canonical href=https://luanrz.github.io/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/redis%E7%BC%93%E5%AD%98%E7%BC%93%E5%AD%98%E5%BB%B6%E8%BF%9F%E4%B8%8E%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88/><link crossorigin=anonymous href=/assets/css/stylesheet.5ed58f4ac5cb2b1025742e6161056c468c3232b9bfc72705b7f9f2da355ff7f3.css integrity="sha256-XtWPSsXLKxAldC5hYQVsRowyMrm/xycFt/ny2jVf9/M=" rel="preload stylesheet" as=style><link rel=icon href=https://luanrz.github.io/images/icon.jpg><link rel=icon type=image/png sizes=16x16 href=https://luanrz.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://luanrz.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://luanrz.github.io/apple-touch-icon.png><link rel=mask-icon href=https://luanrz.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://luanrz.github.io/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/redis%E7%BC%93%E5%AD%98%E7%BC%93%E5%AD%98%E5%BB%B6%E8%BF%9F%E4%B8%8E%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script>const loadScript=(e,t)=>{var n=document.createElement("script");n.onerror=e=>{throw new URIError("The script "+e.target.src+" didn't load correctly.")},t&&(n.onload=t),document.head.insertAdjacentElement("beforeend",n),n.src=e},loadPlantUMLOnNeed=()=>{let e="language-plantuml";document.querySelectorAll("[class^="+e+"]").length>0&&loadScript("https://fastly.jsdelivr.net/gh/jmnote/plantuml-encoder@1.2.4/dist/plantuml-encoder.min.js",()=>{(function(){Array.prototype.forEach.call(document.querySelectorAll("[class^="+e+"]"),function(e){let t=document.createElement("IMG");t.loading="lazy",t.src="http://www.plantuml.com/plantuml/svg/~1"+plantumlEncoder.encode(e.innerText),e.parentNode.insertBefore(t,e),e.style.display="none"})})(),console.log("PlantUML init done")})};window.addEventListener("load",function(){loadPlantUMLOnNeed()})</script><meta property="og:url" content="https://luanrz.github.io/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/redis%E7%BC%93%E5%AD%98%E7%BC%93%E5%AD%98%E5%BB%B6%E8%BF%9F%E4%B8%8E%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88/"><meta property="og:site_name" content="luanrz's blog"><meta property="og:title" content="Redis缓存：缓存延迟与缓存失效"><meta property="og:description" content="Redis缓存延迟指的是：Redis与数据库发生同步过程中Redis数据状态滞后的现象。缓存延迟涉及到数据一致性与缓存更新策略的选择。
Redis缓存失效指的是：因为缓存穿透、缓存击穿、缓存雪崩等原因导致Redis缓存查询不到的情况。"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-02-11T18:48:13+08:00"><meta property="article:modified_time" content="2023-02-11T18:48:13+08:00"><meta property="article:tag" content="Redis"><meta name=twitter:card content="summary"><meta name=twitter:title content="Redis缓存：缓存延迟与缓存失效"><meta name=twitter:description content="Redis缓存延迟指的是：Redis与数据库发生同步过程中Redis数据状态滞后的现象。缓存延迟涉及到数据一致性与缓存更新策略的选择。
Redis缓存失效指的是：因为缓存穿透、缓存击穿、缓存雪崩等原因导致Redis缓存查询不到的情况。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://luanrz.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Redis缓存：缓存延迟与缓存失效","item":"https://luanrz.github.io/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/redis%E7%BC%93%E5%AD%98%E7%BC%93%E5%AD%98%E5%BB%B6%E8%BF%9F%E4%B8%8E%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Redis缓存：缓存延迟与缓存失效","name":"Redis缓存：缓存延迟与缓存失效","description":"Redis缓存延迟指的是：Redis与数据库发生同步过程中Redis数据状态滞后的现象。缓存延迟涉及到数据一致性与缓存更新策略的选择。\nRedis缓存失效指的是：因为缓存穿透、缓存击穿、缓存雪崩等原因导致Redis缓存查询不到的情况。\n","keywords":["Redis"],"articleBody":"Redis缓存延迟指的是：Redis与数据库发生同步过程中Redis数据状态滞后的现象。缓存延迟涉及到数据一致性与缓存更新策略的选择。\nRedis缓存失效指的是：因为缓存穿透、缓存击穿、缓存雪崩等原因导致Redis缓存查询不到的情况。\n下面将分别讨论Redis缓存延迟中的数据一致性与缓存更新策略，以及缓存失效中的缓存穿透、缓存击穿、缓存雪崩问题。\n一、缓存延迟 基于业务数据的时效性要求，Redis缓存延迟的容忍度也会不同，如，对于商品库存与商品详情两种数据来说，商品库存随时变化，而商品详情在新建之后一般不怎么发生变化。因此，商品库存数据的时效性要求就会更高，缓存延迟的时间应当越短越好，商品详情数据则反之。\n业务数据的时效性要求，决定了会选择哪种缓存更新策略来保证数据一致性的强度。\n（一）数据一致性 数据一致性（Consistency）是分布式理论CAP的一部分。\n出现数据不一致，是因为多个组件在同步时出现延迟，这一过程可以发生在在Redis集群内部中的Redis节点之间，也可以发生在Redis集群与数据库之间。后文的Redis更新策略考虑的是后者，即，Redis集群作为一个整体与数据库之间的数据一致性。\n下图演示了在数据库发生变动后，用户查询的数据出现不一致的过程：\n@startuml Redis数据同步顺序图 title Redis数据同步顺序图 autonumber actor User participant Tomcat participant Redis participant MySQL actor Admin activate User activate Admin == 用户首次查询 == User -\u003e\u003e Tomcat ++: 数据查询请求 Tomcat -\u003e\u003e Redis ++: 数据查询指令 return 数据在缓存中不存在 Tomcat -\u003e\u003e MySQL ++: 数据查询命令 return 数据库中的数据 Tomcat -\u003e\u003e Redis ++: 写入Redis return 写入结果 return 最终数据 note right of User 此时的最终数据是最新的 endnote == 数据发生变化 == Admin -\u003e\u003e Tomcat ++: 数据更新请求 Tomcat -\u003e\u003e MySQL ++: 数据更新指令 return 更新结果 Tomcat -\u003e\u003e Redis ++: Redis同步 note right of Tomcat 根据不同的数据一致性要求，选择不同的同步策略 endnote return 同步结果 return 数据更新结果 == 用户第二次查询 == User -\u003e\u003e Tomcat ++: 数据查询请求 Tomcat -\u003e\u003e Redis ++: 数据查询指令 return Redis中的数据 note right of Tomcat 此时，Redis中的数据可能存在**数据不一致**的情况， 因为数据库的数据发生了变化而Redis没有来得及更新 endnote return 最终数据 note right of User 此时的最终数据可能是旧的 endnote @enduml 由于在数据发生变化时，Redis同步这一步存在延迟，导致用户第二次查询的数据是数据库更新前的Redis中的旧数据。用户什么时候获取新的数据，取决于业务上数据时效性的要求，数据时效性要求越高，Redis的更新时机就应当越早。\n（二）缓存更新策略 根据数据一致性的强度从低到高，Redis的更新策略有：内存淘汰、超时过期、主动更新。\n内存淘汰 内存淘汰是指，由Redis根据自身内存使用状态来淘汰数据的过程。这种缓存更新机制不需要开发人员在代码层面做任何操作，开发成本较低，但数据一致性较差，一般适用于不经常变动的缓存数据。\n可以在Redis交互界面设置maxmemory的值，来改变Redis最大内存：\nredis set config maxmemory 2048m 也可以在redis.conf配置文件中修改对应值：\nmaxmemory 2048m 超时过期 超时过期是指，在创建缓存记录时为其指定一个有效期，达到有效期后Redis自动删除对应记录的过程。这种缓存更新机制只需要开发人员在新建缓存对象时指定其过期时间即可，开发成本较低，数据一致性一般，一般适用于偶尔变动的缓存数据。\n在Redis控制台中，有三种方式设置过期时间：expire、set与setex，它们的效果都是一样的，同时，可以使用ttl查询剩余存活时间。如下所示：\nset key value # 写入缓存 expire key 100 # 设置存活时间 set key value EX 100 # 写入缓存的同时设置过期时间 setex key 100 value # 同上 ttl key # 查看剩余存活时间 主动更新 主动更新是指，数据库发生变动时由代码主动调用Redis服务同步修改缓存数据的过程。这种缓存更新策略需要开发人员主动开发部分代码，开发成本适中，数据一致性较强，一般适用于经常变动的缓存数据，并将超时过期作为兜底方案一起使用。\n更新缓存时，一般采取“先写数据库、再删缓存”的步骤。先写数据库的原因是：缓存的写速度比数据库要快很多，更耗时的操作先做可以确保在并发过程中减小数据冲突的概率。同时，一般使用del删除缓存，下次查询时会自动将数据库中将最新的记录重新写入Redis，比起重复set，del更快。\n最后，数据库与Redis的更新要保证原子性，即，要么同时成功，要么同时失败。解决方式是将数据库和Redis的更新操作放到同一个事务中，分布式环境则需要考虑TCC分布式事务。\n二、缓存失效 根据严重程度从低到高，缓存失效包括以下场景：缓存穿透、缓存击穿、缓存雪崩。\n（一）缓存穿透 缓存穿透是指，用户查询了缓存和数据库中都不存在的数据，导致缓存永不生效，请求直接发往数据库的现象。\n解决缓存穿透的常用方法是：缓存空对象与布隆过滤。\n缓存空对象是指，在数据库未查到记录时，将一个空值存入缓存，这样下次再次查询这个数据时，将直接由Redis返回空，以减轻数据库的压力。\n布隆过滤是指，查询Redis之前，优先在布隆过滤器中判断数据是否不存在，布隆过滤器根据一定的Hash规则认为数据不存在，则该数据就一定不存在，直接返回空即可。该方案实现简单，但会造成额外的内存消耗与短期的数据不一致。\n一般缓存穿透发生的原因是恶意用户试图自行组装参数对系统发起攻击，因此，除了上述两种方式外，也可以在查询数据之前，做好用户权限及基础数据格式的校验，避免无效的请求继续往后走。该方案实现复杂，但内存占用较少。\n（二）缓存击穿 缓存击穿是指，被高并发访问的热点数据过期导致大量请求直接发往数据库的现象。\n如果不巧的是该热点数据缓存的重建过程又比较缓慢，那么问题会更严重，在Redis记录写入之前，若干进程将会同时执行重复的重建操作，这给数据库的压力将是巨大的。\n解决缓存击穿的常用方法是：增加互斥锁、热点数据逻辑过期。\n互斥锁是指，在重建缓存记录查询数据库操作只交给一个线程去做，其它线程等待，直到缓存中有记录为止。该方案实现简单但性能较差。\n逻辑过期则是指，热点数据不再设置Redis的自带过期时间，而是在数据中增加一个自定义的过期时间，过期删除操作交给代码去执行。该方案实现复杂但性能较好。\n（三）缓存雪崩 缓存雪崩是指，Redis出现大批量不可用的现象。\n出现大批量不可用的原因有两点，一是Redis服务宕机，二是大量缓存记录同时超时过期。针对服务宕机，可以采取Redis集群来提高Redis的可用性。针对大量Redis同时超时过期，可以在设置超时时间时偏移一个随机值，避免同时过期。\n同时，为了避免大量请求直接发往数据库，可以为缓存业务增加降级限流策略。在分布式系统中，多级缓存也可以减轻缓存雪崩带来的影响。\n参考文档\nRedis官方网站 黑马程序员Redis入门到实战教程 ","wordCount":"2703","inLanguage":"zh","datePublished":"2023-02-11T18:48:13+08:00","dateModified":"2023-02-11T18:48:13+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://luanrz.github.io/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/redis%E7%BC%93%E5%AD%98%E7%BC%93%E5%AD%98%E5%BB%B6%E8%BF%9F%E4%B8%8E%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88/"},"publisher":{"@type":"Organization","name":"luanrz's blog","logo":{"@type":"ImageObject","url":"https://luanrz.github.io/images/icon.jpg"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://luanrz.github.io/ accesskey=h title="luanrz's blog (Alt + H)">luanrz's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://luanrz.github.io/ title=首页><span>首页</span></a></li><li><a href=https://luanrz.github.io/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://luanrz.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://luanrz.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://luanrz.github.io/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Redis缓存：缓存延迟与缓存失效</h1><div class=post-meta><span title='2023-02-11 18:48:13 +0800 +0800'>2023-02-11</span>&nbsp;·&nbsp;<span>6 分钟</span>&nbsp;·&nbsp;<span>2703 字</span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e4%b8%80%e7%bc%93%e5%ad%98%e5%bb%b6%e8%bf%9f aria-label=一、缓存延迟>一、缓存延迟</a><ul><li><a href=#%e4%b8%80%e6%95%b0%e6%8d%ae%e4%b8%80%e8%87%b4%e6%80%a7 aria-label=（一）数据一致性>（一）数据一致性</a></li><li><a href=#%e4%ba%8c%e7%bc%93%e5%ad%98%e6%9b%b4%e6%96%b0%e7%ad%96%e7%95%a5 aria-label=（二）缓存更新策略>（二）缓存更新策略</a></li></ul></li><li><a href=#%e4%ba%8c%e7%bc%93%e5%ad%98%e5%a4%b1%e6%95%88 aria-label=二、缓存失效>二、缓存失效</a><ul><li><a href=#%e4%b8%80%e7%bc%93%e5%ad%98%e7%a9%bf%e9%80%8f aria-label=（一）缓存穿透>（一）缓存穿透</a></li><li><a href=#%e4%ba%8c%e7%bc%93%e5%ad%98%e5%87%bb%e7%a9%bf aria-label=（二）缓存击穿>（二）缓存击穿</a></li><li><a href=#%e4%b8%89%e7%bc%93%e5%ad%98%e9%9b%aa%e5%b4%a9 aria-label=（三）缓存雪崩>（三）缓存雪崩</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>Redis缓存延迟指的是：Redis与数据库发生同步过程中Redis数据状态滞后的现象。缓存延迟涉及到数据一致性与缓存更新策略的选择。</p><p>Redis缓存失效指的是：因为缓存穿透、缓存击穿、缓存雪崩等原因导致Redis缓存查询不到的情况。</p><p>下面将分别讨论Redis缓存延迟中的数据一致性与缓存更新策略，以及缓存失效中的缓存穿透、缓存击穿、缓存雪崩问题。</p><h2 id=一缓存延迟>一、缓存延迟<a hidden class=anchor aria-hidden=true href=#一缓存延迟>#</a></h2><p>基于业务数据的时效性要求，Redis缓存延迟的容忍度也会不同，如，对于商品库存与商品详情两种数据来说，商品库存随时变化，而商品详情在新建之后一般不怎么发生变化。因此，商品库存数据的时效性要求就会更高，缓存延迟的时间应当越短越好，商品详情数据则反之。</p><p>业务数据的时效性要求，决定了会选择哪种缓存更新策略来保证数据一致性的强度。</p><h3 id=一数据一致性>（一）数据一致性<a hidden class=anchor aria-hidden=true href=#一数据一致性>#</a></h3><blockquote><p>数据一致性（Consistency）是分布式理论CAP的一部分。</p></blockquote><p>出现数据不一致，是因为多个组件在同步时出现延迟，这一过程可以发生在在Redis集群内部中的Redis节点之间，也可以发生在Redis集群与数据库之间。后文的<a href=#%E4%BA%8Credis%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5>Redis更新策略</a>考虑的是后者，即，Redis集群作为一个整体与数据库之间的数据一致性。</p><p>下图演示了在数据库发生变动后，用户查询的数据出现不一致的过程：</p><pre tabindex=0><code class=language-plantuml data-lang=plantuml>@startuml Redis数据同步顺序图
title Redis数据同步顺序图

autonumber

actor User
participant Tomcat
participant Redis
participant MySQL
actor Admin

activate User
activate Admin


== 用户首次查询 ==
User -&gt;&gt; Tomcat ++: 数据查询请求
Tomcat -&gt;&gt; Redis ++: 数据查询指令
return 数据在缓存中不存在
Tomcat -&gt;&gt; MySQL ++: 数据查询命令
return 数据库中的数据
Tomcat -&gt;&gt; Redis ++: 写入Redis
return 写入结果
return 最终数据
note right of User
此时的最终数据是最新的
endnote

== 数据发生变化 ==
Admin -&gt;&gt; Tomcat ++: 数据更新请求
Tomcat -&gt;&gt; MySQL ++: 数据更新指令
return 更新结果
Tomcat -&gt;&gt; Redis ++: Redis同步
note right of Tomcat
根据不同的数据一致性要求，选择不同的同步策略
endnote
return 同步结果
return 数据更新结果


== 用户第二次查询 ==
User -&gt;&gt; Tomcat ++: 数据查询请求
Tomcat -&gt;&gt; Redis ++: 数据查询指令
return Redis中的数据
note right of Tomcat
此时，Redis中的数据可能存在**数据不一致**的情况，
因为数据库的数据发生了变化而Redis没有来得及更新
endnote
return 最终数据
note right of User
此时的最终数据可能是旧的
endnote

@enduml
</code></pre><p>由于在数据发生变化时，Redis同步这一步存在延迟，导致用户第二次查询的数据是数据库更新前的Redis中的旧数据。用户什么时候获取新的数据，取决于业务上数据时效性的要求，数据时效性要求越高，Redis的更新时机就应当越早。</p><h3 id=二缓存更新策略>（二）缓存更新策略<a hidden class=anchor aria-hidden=true href=#二缓存更新策略>#</a></h3><p>根据数据一致性的强度从低到高，Redis的更新策略有：内存淘汰、超时过期、主动更新。</p><ol><li>内存淘汰</li></ol><p>内存淘汰是指，由Redis根据自身内存使用状态来淘汰数据的过程。这种缓存更新机制不需要开发人员在代码层面做任何操作，开发成本较低，但数据一致性较差，一般适用于不经常变动的缓存数据。</p><p>可以在Redis交互界面设置maxmemory的值，来改变Redis最大内存：</p><pre tabindex=0><code>redis set config maxmemory 2048m
</code></pre><p>也可以在<code>redis.conf</code>配置文件中修改对应值：</p><pre tabindex=0><code>maxmemory 2048m
</code></pre><ol start=2><li>超时过期</li></ol><p>超时过期是指，在创建缓存记录时为其指定一个有效期，达到有效期后Redis自动删除对应记录的过程。这种缓存更新机制只需要开发人员在新建缓存对象时指定其过期时间即可，开发成本较低，数据一致性一般，一般适用于偶尔变动的缓存数据。</p><p>在Redis控制台中，有三种方式设置过期时间：<code>expire</code>、<code>set</code>与<code>setex</code>，它们的效果都是一样的，同时，可以使用<code>ttl</code>查询剩余存活时间。如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-shell data-lang=shell><span style=display:flex><span>set key value <span style=color:#75715e># 写入缓存</span>
</span></span><span style=display:flex><span>expire key <span style=color:#ae81ff>100</span> <span style=color:#75715e># 设置存活时间</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>set key value EX <span style=color:#ae81ff>100</span> <span style=color:#75715e># 写入缓存的同时设置过期时间</span>
</span></span><span style=display:flex><span>setex key <span style=color:#ae81ff>100</span> value <span style=color:#75715e># 同上</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ttl key <span style=color:#75715e># 查看剩余存活时间</span>
</span></span></code></pre></div><ol start=3><li>主动更新</li></ol><p>主动更新是指，数据库发生变动时由代码主动调用Redis服务同步修改缓存数据的过程。这种缓存更新策略需要开发人员主动开发部分代码，开发成本适中，数据一致性较强，一般适用于经常变动的缓存数据，并将超时过期作为兜底方案一起使用。</p><p>更新缓存时，一般采取“先写数据库、再删缓存”的步骤。先写数据库的原因是：缓存的写速度比数据库要快很多，更耗时的操作先做可以确保在并发过程中减小数据冲突的概率。同时，一般使用<code>del</code>删除缓存，下次查询时会自动将数据库中将最新的记录重新写入Redis，比起重复<code>set</code>，<code>del</code>更快。</p><p>最后，数据库与Redis的更新要保证原子性，即，要么同时成功，要么同时失败。解决方式是将数据库和Redis的更新操作放到同一个事务中，分布式环境则需要考虑TCC分布式事务。</p><h2 id=二缓存失效>二、缓存失效<a hidden class=anchor aria-hidden=true href=#二缓存失效>#</a></h2><p>根据严重程度从低到高，缓存失效包括以下场景：缓存穿透、缓存击穿、缓存雪崩。</p><h3 id=一缓存穿透>（一）缓存穿透<a hidden class=anchor aria-hidden=true href=#一缓存穿透>#</a></h3><p>缓存穿透是指，用户查询了缓存和数据库中都不存在的数据，导致缓存永不生效，请求直接发往数据库的现象。</p><p>解决缓存穿透的常用方法是：缓存空对象与布隆过滤。</p><p>缓存空对象是指，在数据库未查到记录时，将一个空值存入缓存，这样下次再次查询这个数据时，将直接由Redis返回空，以减轻数据库的压力。</p><p>布隆过滤是指，查询Redis之前，优先在布隆过滤器中判断数据是否不存在，布隆过滤器根据一定的Hash规则认为数据不存在，则该数据就一定不存在，直接返回空即可。该方案实现简单，但会造成额外的内存消耗与短期的数据不一致。</p><p>一般缓存穿透发生的原因是恶意用户试图自行组装参数对系统发起攻击，因此，除了上述两种方式外，也可以在查询数据之前，做好用户权限及基础数据格式的校验，避免无效的请求继续往后走。该方案实现复杂，但内存占用较少。</p><h3 id=二缓存击穿>（二）缓存击穿<a hidden class=anchor aria-hidden=true href=#二缓存击穿>#</a></h3><p>缓存击穿是指，被高并发访问的热点数据过期导致大量请求直接发往数据库的现象。</p><p>如果不巧的是该热点数据缓存的重建过程又比较缓慢，那么问题会更严重，在Redis记录写入之前，若干进程将会同时执行重复的重建操作，这给数据库的压力将是巨大的。</p><p>解决缓存击穿的常用方法是：增加互斥锁、热点数据逻辑过期。</p><p>互斥锁是指，在重建缓存记录查询数据库操作只交给一个线程去做，其它线程等待，直到缓存中有记录为止。该方案实现简单但性能较差。</p><p>逻辑过期则是指，热点数据不再设置Redis的自带过期时间，而是在数据中增加一个自定义的过期时间，过期删除操作交给代码去执行。该方案实现复杂但性能较好。</p><h3 id=三缓存雪崩>（三）缓存雪崩<a hidden class=anchor aria-hidden=true href=#三缓存雪崩>#</a></h3><p>缓存雪崩是指，Redis出现大批量不可用的现象。</p><p>出现大批量不可用的原因有两点，一是Redis服务宕机，二是大量缓存记录同时超时过期。针对服务宕机，可以采取Redis集群来提高Redis的可用性。针对大量Redis同时超时过期，可以在设置超时时间时偏移一个随机值，避免同时过期。</p><p>同时，为了避免大量请求直接发往数据库，可以为缓存业务增加降级限流策略。在分布式系统中，多级缓存也可以减轻缓存雪崩带来的影响。</p><blockquote><p>参考文档</p></blockquote><ol><li><a href=https://redis.com>Redis官方网站</a></li><li><a href=https://www.bilibili.com/video/BV1cr4y1671t/>黑马程序员Redis入门到实战教程</a></li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://luanrz.github.io/tags/redis/>Redis</a></li></ul><nav class=paginav><a class=prev href=https://luanrz.github.io/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/redis%E7%BC%93%E5%AD%98%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%E7%AE%80%E4%BB%8B/><span class=title>« 上一页</span><br><span>Redis缓存：分布式缓存配置与多级缓存简介</span>
</a><a class=next href=https://luanrz.github.io/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/redis%E7%BC%93%E5%AD%98%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/><span class=title>下一页 »</span><br><span>Redis缓存：常用数据结构与基本用法</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://luanrz.github.io/>luanrz's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>