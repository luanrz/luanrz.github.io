<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>SpringCloud与K8S中的服务网关 | luanrz's blog</title><meta name=keywords content="Java,Spring"><meta name=description content="微服务中的服务网关至少有以下作用：

转发（服务路由与负载均衡）
鉴权（身份认证与权限校验）
限流（流量控制与熔断）

它们在SpringCloud和K8S中有着不同的实现方式："><meta name=author content><link rel=canonical href=https://luanrz.github.io/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/springcloud%E4%B8%8Ek8s%E4%B8%AD%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3/><link crossorigin=anonymous href=/assets/css/stylesheet.ed6c30fee125be816b653632a2732f92313b593583d98576c9eb2bf33a42b6e1.css integrity="sha256-7Www/uElvoFrZTYyonMvkjE7WTWD2YV2yesr8zpCtuE=" rel="preload stylesheet" as=style><link rel=icon href=https://luanrz.github.io/images/icon.jpg><link rel=icon type=image/png sizes=16x16 href=https://luanrz.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://luanrz.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://luanrz.github.io/apple-touch-icon.png><link rel=mask-icon href=https://luanrz.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://luanrz.github.io/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/springcloud%E4%B8%8Ek8s%E4%B8%AD%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script>const loadScript=(e,t)=>{var n=document.createElement("script");n.onerror=e=>{throw new URIError("The script "+e.target.src+" didn't load correctly.")},t&&(n.onload=t),document.head.insertAdjacentElement("beforeend",n),n.src=e},loadPlantUMLOnNeed=()=>{let e="language-plantuml";document.querySelectorAll("[class^="+e+"]").length>0&&loadScript("https://fastly.jsdelivr.net/gh/jmnote/plantuml-encoder@1.2.4/dist/plantuml-encoder.min.js",()=>{(function(){Array.prototype.forEach.call(document.querySelectorAll("[class^="+e+"]"),function(e){let t=document.createElement("IMG");t.loading="lazy",t.src="http://www.plantuml.com/plantuml/svg/~1"+plantumlEncoder.encode(e.innerText),e.parentNode.insertBefore(t,e),e.style.display="none"})})(),console.log("PlantUML init done")})};window.addEventListener("load",function(){loadPlantUMLOnNeed()})</script><meta property="og:url" content="https://luanrz.github.io/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/springcloud%E4%B8%8Ek8s%E4%B8%AD%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3/"><meta property="og:site_name" content="luanrz's blog"><meta property="og:title" content="SpringCloud与K8S中的服务网关"><meta property="og:description" content="微服务中的服务网关至少有以下作用：
转发（服务路由与负载均衡） 鉴权（身份认证与权限校验） 限流（流量控制与熔断） 它们在SpringCloud和K8S中有着不同的实现方式："><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-05-12T20:00:00+08:00"><meta property="article:modified_time" content="2023-05-12T20:00:00+08:00"><meta property="article:tag" content="Java"><meta property="article:tag" content="Spring"><meta name=twitter:card content="summary"><meta name=twitter:title content="SpringCloud与K8S中的服务网关"><meta name=twitter:description content="微服务中的服务网关至少有以下作用：

转发（服务路由与负载均衡）
鉴权（身份认证与权限校验）
限流（流量控制与熔断）

它们在SpringCloud和K8S中有着不同的实现方式："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://luanrz.github.io/posts/"},{"@type":"ListItem","position":3,"name":"SpringCloud与K8S中的服务网关","item":"https://luanrz.github.io/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/springcloud%E4%B8%8Ek8s%E4%B8%AD%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"SpringCloud与K8S中的服务网关","name":"SpringCloud与K8S中的服务网关","description":"微服务中的服务网关至少有以下作用：\n转发（服务路由与负载均衡） 鉴权（身份认证与权限校验） 限流（流量控制与熔断） 它们在SpringCloud和K8S中有着不同的实现方式：\n","keywords":["Java","Spring"],"articleBody":"微服务中的服务网关至少有以下作用：\n转发（服务路由与负载均衡） 鉴权（身份认证与权限校验） 限流（流量控制与熔断） 它们在SpringCloud和K8S中有着不同的实现方式：\nSpringCloud K8S 服务网关 SpringCloudGateway、Zuul Ingress 服务路由是网关的核心功能，下面将基于SpringCloudGateway与Ingress分别介绍SpinrgCloud与K8S中服务路由的使用方法。\n一、SpringCloud中的服务网关 （一）启动网关服务 spring-cloud-starter-gateway是实现SpringCloudGateway的核心依赖，同时，也可引入nacos-discovery与loadbalancer依赖以支持注册中心与负载均衡。如下所示：\norg.springframework.cloud spring-cloud-starter-gateway com.alibaba.cloud spring-cloud-starter-alibaba-nacos-discovery org.springframework.cloud spring-cloud-starter-loadbalancer 随后，在application.yml文件中配置路由转发规则：\nserver: port: 8888 # 网关端口 spring: application: name: gateway # 服务名称 cloud: nacos: server-addr: localhost:8848 # nacos地址 gateway: routes: # 网关路由配置 - id: nacos-provider # 路由id，全局唯一 uri: lb://nacos-provider # 路由目的地 predicates: # 路由断言，符合断言条件才会跳转到路由目的地 - Path=/echo/** # 请求路径断言 filters: # 路由过滤器，对请求和响应做处理 - AddResponseHeader=X-Response-Special, Special # 当前路由专用过滤器 default-filters: - AddResponseHeader=X-Response-Default, Default # 默认过滤器 这里的uri使用的是lb协议，其会默认从注册中心找到对应的服务，如果使用k8s的负载均衡或不使用负载均衡，uri可以使用http协议，如：http://localhost:8081。\n这里假定本地已经启动了nacos注册中心服务和nacos-provider服务，nacos-provider的代码详见github。有关predicates和filters，详见后文。\n随后，定义启动类：\n@SpringBootApplication public class GatewayApplication { public static void main(String[] args) { SpringApplication.run(GatewayApplication.class, args); } } 上述代码详见github。\n启动并访问：\ncurl \"http://localhost:8888/echo?name=zhangsan\" 可以看到正常打印响应结果:\necho:zhangsan 至此，该网关已经实现了对nacos-provider服务的路由转发，用户无需知道（也不应该知道）nacos-provider的访问地址，直接可以通关网关进行访问。\n（二）路由断言与过滤 上述配置文件中，Path请求路径断言由PathRoutePredicateFactory处理，AddResponseHeader由AddResponseHeaderGatewayFilterFactory处理，断言工厂和路由过滤器工厂的详细信息可参见官网Route Predicate Factories与GatewayFilter Factories。\n除了上述配置文件中定义的路由专用过滤器（routes.filters）和默认过滤器（default-filters）外，SpringCloudGateway还支持一种可定制性更强的全局过滤器（GlobalFilter）。一个示例如下：\n@Component @Order(-1) public class AddResponseHeaderGlobalFilter implements GlobalFilter { @Override public Mono\u003cVoid\u003e filter(ServerWebExchange exchange, GatewayFilterChain chain) { ServerHttpResponse response = exchange.getResponse(); response.getHeaders().set(\"X-Response-Global\", \"Global\"); return chain.filter(exchange); } } 该过滤器与上述配置文件中的AddResponseHeader过滤器实现一样的功能：增强响应头。\n再次重启应用，并发送请求：\ncurl -i \"http://localhost:8888/echo?name=zhangsan\" # curl -i参数打印响应头 响应结果如下:\nHTTP/1.1 200 OK X-Response-Default: Default X-Response-Special: Special X-Response-Global: Global Content-Type: text/plain;charset=UTF-8 Content-Length: 13 Date: Sat, 10 Jun 2023 06:37:58 GMT echo:zhangsan 可以看到，三个过滤器都生效了。上述过滤器存在以下执行顺序：\n以Order值排序。全局过滤器的Order由用户指定（使用@Order注解或实现Ordered接口）。默认过滤器和路由专用过滤器的Order则从1开始计数，按照定义的顺序累加，同时，默认过滤器与专用过滤器的Order值独立累加。 若Order值一致，则以默认过滤器 \u003e 路由专用过滤器 \u003e 全局过滤器排序。 二、K8S中的服务网关 （一）启动一个应用 启动一个deployment kubectl create deployment web --image=nginx 暴露一个service kubectl expose deployment web --type=NodePort --port=8080 --target-port=80 kubectl get service web 通过minikube调用服务 minikube service web --url # 输出类似于 http://192.168.49.2:31959 curl http://192.168.49.2:31959 192.168.49.2是minikube的集群ip，使用ifconfig命令查看网络适配器情况，可以看到一个minikube的专用IP网段192.168.49.1。\n正常将会显示nginx的首页html文件内容。这是通过minikube自带的service指令实现访问minikube内部service的方法，后续将会基于Ingress提供更通用的外部访问服务的方法。\n（二）启用Ingress控制器 在使用Ingress之前，需要先启用Ingress控制器。Minikube支持在本地环境快速启用Ingress控制器，下面将以Minikube为例介绍Ingress的配置过程。\n生产环境Ingress控制器可以参考Ingress-Nginx Controller Installation Guide。\n启动minikube minikube start --image-mirror-country='cn' 启用Ingress控制器 minikube addons enable ingress 国内环境可能拉取不了镜像，可以参考附录minikube在国内环境启用addons方法。\n查看Ingress控制器状态 kubectl get pods -n ingress-nginx 结果如下：\nNAME READY STATUS RESTARTS AGE ingress-nginx-admission-create-x98cn 0/1 Completed 0 90m ingress-nginx-admission-patch-mscpc 0/1 Completed 0 90m ingress-nginx-controller-7b7b49467c-4kt7m 1/1 Running 0 90m （三）创建Ingress 定义Ingress配置文件 example-ingress.yaml:\napiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: example-ingress annotations: nginx.ingress.kubernetes.io/rewrite-target: /$1 spec: rules: - host: hello-world.info http: paths: - path: / pathType: Prefix backend: service: name: web port: number: 8080 该配置文件定义了hello-world.info域名到web这个service的转发规则。\n启动Ingress kubectl create -f example-ingress.yaml 查看Ingress状态 kubectl get ingress example-ingress 结果如下：\nNAME CLASS HOSTS ADDRESS PORTS AGE example-ingress nginx hello-world.info 192.168.49.2 80 44s 通过Ingress访问服务 curl --resolve \"hello-world.info:80:$( minikube ip )\" -i http://hello-world.info 正常将会显示nginx的首页html文件内容。其中minikube ip是minikube的集群IP（192.168.49.2），curl --resolve定义了域名解析（也可在本机host中配置）。\n至此，该Ingress实现了以hello-world.info域名为入口，到pod内部的流量转发。\n后续可按需基于Ingress规则配置更多的服务路由转发策略。\n三、总结 SpringCloud通过SpringCloudGateway等组件实现网关。SpringCloudGateway是用Java开发，可定制性更强。其包括：服务路由、断言、过滤、断路器支持、服务发现支持、限流等功能。\nK8S通过Ingress实现网关，除了前面描述的服务路由功能外，Ingress也支持其它网关功能（如：鉴权、限流等等）。Ingress服务需要依赖于特定的Ingress控制器，比如NGINX Ingress Controller。NGINX Ingress网关的功能更多地依赖于NGINX本身的特性，有关NGINX Ingress的更多特性，也可参见其官网。\n与SpringCloud与K8S中的服务配置中类似：SpringCloud偏向于开发，而K8S则更偏向于运维。有关技术选型，需视情况而定。\n附录 minikube在国内环境启用addons方法 在本地拉取docker镜像 docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/nginx-ingress-controller:v1.7.0 docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/kube-webhook-certgen:v20230312-helm-chart-4.5.2-28-g66a760794 版本号可按需修改。\n将本地镜像加载到minikube集群中 minikube image load registry.cn-hangzhou.aliyuncs.com/google_containers/nginx-ingress-controller:v1.7.0 minikube image load registry.cn-hangzhou.aliyuncs.com/google_containers/kube-webhook-certgen:v20230312-helm-chart-4.5.2-28-g66a760794 上一步的docker pull不是必须的。如果上一步执行了docker pull，这里的load命令就会从本地Docker镜像中拷贝，反之则从远程仓库拉取。\n启用addons，并修改镜像地址 minikube addons enable ingress --images=\"KubeWebhookCertgenCreate=registry.cn-hangzhou.aliyuncs.com/google_containers/kube-webhook-certgen:v20230312-helm-chart-4.5.2-28-g66a760794,KubeWebhookCertgenPatch=registry.cn-hangzhou.aliyuncs.com/google_containers/kube-webhook-certgen:v20230312-helm-chart-4.5.2-28-g66a760794,IngressController=google_containers/nginx-ingress-controller:v1.7.0\" --registries=\"IngressController=registry.cn-hangzhou.aliyuncs.com\" 参考文档\n《深入理解SpringCloud与实战 方剑 著》 SpringCloud官方网站 黑马程序员SpringCloud微服务技术栈教程 Kubernetes Ingress 介绍 在 Minikube 环境中使用 NGINX Ingress 控制器配置 Ingress Ingress-Nginx Controller Installation Guide NGINX Ingress Controller Minikube安装ingress插件的有效方法 ","wordCount":"2988","inLanguage":"zh","datePublished":"2023-05-12T20:00:00+08:00","dateModified":"2023-05-12T20:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://luanrz.github.io/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/springcloud%E4%B8%8Ek8s%E4%B8%AD%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3/"},"publisher":{"@type":"Organization","name":"luanrz's blog","logo":{"@type":"ImageObject","url":"https://luanrz.github.io/images/icon.jpg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://luanrz.github.io/ accesskey=h title="luanrz's blog (Alt + H)">luanrz's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://luanrz.github.io/ title=首页><span>首页</span></a></li><li><a href=https://luanrz.github.io/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://luanrz.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://luanrz.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://luanrz.github.io/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">SpringCloud与K8S中的服务网关</h1><div class=post-meta><span title='2023-05-12 20:00:00 +0800 +0800'>2023-05-12</span>&nbsp;·&nbsp;6 分钟&nbsp;·&nbsp;2988 字</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e4%b8%80springcloud%e4%b8%ad%e7%9a%84%e6%9c%8d%e5%8a%a1%e7%bd%91%e5%85%b3 aria-label=一、SpringCloud中的服务网关>一、SpringCloud中的服务网关</a><ul><li><a href=#%e4%b8%80%e5%90%af%e5%8a%a8%e7%bd%91%e5%85%b3%e6%9c%8d%e5%8a%a1 aria-label=（一）启动网关服务>（一）启动网关服务</a></li><li><a href=#%e4%ba%8c%e8%b7%af%e7%94%b1%e6%96%ad%e8%a8%80%e4%b8%8e%e8%bf%87%e6%bb%a4 aria-label=（二）路由断言与过滤>（二）路由断言与过滤</a></li></ul></li><li><a href=#%e4%ba%8ck8s%e4%b8%ad%e7%9a%84%e6%9c%8d%e5%8a%a1%e7%bd%91%e5%85%b3 aria-label=二、K8S中的服务网关>二、K8S中的服务网关</a><ul><li><a href=#%e4%b8%80%e5%90%af%e5%8a%a8%e4%b8%80%e4%b8%aa%e5%ba%94%e7%94%a8 aria-label=（一）启动一个应用>（一）启动一个应用</a></li><li><a href=#%e4%ba%8c%e5%90%af%e7%94%a8ingress%e6%8e%a7%e5%88%b6%e5%99%a8 aria-label=（二）启用Ingress控制器>（二）启用Ingress控制器</a></li><li><a href=#%e4%b8%89%e5%88%9b%e5%bb%baingress aria-label=（三）创建Ingress>（三）创建Ingress</a></li></ul></li><li><a href=#%e4%b8%89%e6%80%bb%e7%bb%93 aria-label=三、总结>三、总结</a></li><li><a href=#%e9%99%84%e5%bd%95 aria-label=附录>附录</a><ul><li><a href=#minikube%e5%9c%a8%e5%9b%bd%e5%86%85%e7%8e%af%e5%a2%83%e5%90%af%e7%94%a8addons%e6%96%b9%e6%b3%95 aria-label=minikube在国内环境启用addons方法>minikube在国内环境启用addons方法</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement||=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e}),elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>微服务中的服务网关至少有以下作用：</p><ul><li>转发（服务路由与负载均衡）</li><li>鉴权（身份认证与权限校验）</li><li>限流（流量控制与熔断）</li></ul><p>它们在SpringCloud和K8S中有着不同的实现方式：</p><table><thead><tr><th></th><th>SpringCloud</th><th>K8S</th></tr></thead><tbody><tr><td>服务网关</td><td>SpringCloudGateway、Zuul</td><td>Ingress</td></tr></tbody></table><p>服务路由是网关的核心功能，下面将基于SpringCloudGateway与Ingress分别介绍SpinrgCloud与K8S中服务路由的使用方法。</p><h2 id=一springcloud中的服务网关>一、SpringCloud中的服务网关<a hidden class=anchor aria-hidden=true href=#一springcloud中的服务网关>#</a></h2><h3 id=一启动网关服务>（一）启动网关服务<a hidden class=anchor aria-hidden=true href=#一启动网关服务>#</a></h3><p><code>spring-cloud-starter-gateway</code>是实现SpringCloudGateway的核心依赖，同时，也可引入<code>nacos-discovery</code>与<code>loadbalancer</code>依赖以支持注册中心与负载均衡。如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;dependencies&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>&lt;!-- 网关依赖 --&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;dependency&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;groupId&gt;</span>org.springframework.cloud<span style=color:#f92672>&lt;/groupId&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;artifactId&gt;</span>spring-cloud-starter-gateway<span style=color:#f92672>&lt;/artifactId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;/dependency&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>&lt;!-- 注册中心依赖 --&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;dependency&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;groupId&gt;</span>com.alibaba.cloud<span style=color:#f92672>&lt;/groupId&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;artifactId&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span style=color:#f92672>&lt;/artifactId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;/dependency&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>&lt;!-- 负载均衡（不加此依赖，路由地址uri使用lb协议可能会503报错） --&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;dependency&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;groupId&gt;</span>org.springframework.cloud<span style=color:#f92672>&lt;/groupId&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;artifactId&gt;</span>spring-cloud-starter-loadbalancer<span style=color:#f92672>&lt;/artifactId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;/dependency&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/dependencies&gt;</span>
</span></span></code></pre></div><p>随后，在<code>application.yml</code>文件中配置路由转发规则：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#f92672>server</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>port</span>: <span style=color:#ae81ff>8888</span> <span style=color:#75715e># 网关端口</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spring</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>application</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#ae81ff>gateway</span> <span style=color:#75715e># 服务名称</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>cloud</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>nacos</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>server-addr</span>: <span style=color:#ae81ff>localhost:8848</span> <span style=color:#75715e># nacos地址</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>gateway</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>routes</span>: <span style=color:#75715e># 网关路由配置</span>
</span></span><span style=display:flex><span>        - <span style=color:#f92672>id</span>: <span style=color:#ae81ff>nacos-provider</span> <span style=color:#75715e># 路由id，全局唯一</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>uri</span>: <span style=color:#ae81ff>lb://nacos-provider</span> <span style=color:#75715e># 路由目的地</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>predicates</span>: <span style=color:#75715e># 路由断言，符合断言条件才会跳转到路由目的地</span>
</span></span><span style=display:flex><span>            - <span style=color:#ae81ff>Path=/echo/**</span> <span style=color:#75715e># 请求路径断言</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>filters</span>: <span style=color:#75715e># 路由过滤器，对请求和响应做处理</span>
</span></span><span style=display:flex><span>            - <span style=color:#ae81ff>AddResponseHeader=X-Response-Special, Special</span> <span style=color:#75715e># 当前路由专用过滤器</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>default-filters</span>:
</span></span><span style=display:flex><span>        - <span style=color:#ae81ff>AddResponseHeader=X-Response-Default, Default</span> <span style=color:#75715e># 默认过滤器</span>
</span></span></code></pre></div><p>这里的uri使用的是lb协议，其会默认从注册中心找到对应的服务，如果使用k8s的负载均衡或不使用负载均衡，uri可以使用http协议，如：http://localhost:8081。</p><p>这里假定本地已经启动了nacos注册中心服务和<code>nacos-provider</code>服务，<code>nacos-provider</code>的代码详见<a href=https://github.com/luanrz/spring-cloud-demo/tree/main/service-registry-discovery/nacos-provider>github</a>。有关<code>predicates</code>和<code>filters</code>，详见<a href=#%E4%BA%8C%E8%B7%AF%E7%94%B1%E6%96%AD%E8%A8%80%E4%B8%8E%E8%BF%87%E6%BB%A4>后文</a>。</p><p>随后，定义启动类：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@SpringBootApplication</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GatewayApplication</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        SpringApplication.<span style=color:#a6e22e>run</span>(GatewayApplication.<span style=color:#a6e22e>class</span>, args);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>上述代码详见<a href=https://github.com/luanrz/spring-cloud-demo/tree/main/gateway/spring-cloud-gateway>github</a>。</p></blockquote><p>启动并访问：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl <span style=color:#e6db74>&#34;http://localhost:8888/echo?name=zhangsan&#34;</span>
</span></span></code></pre></div><p>可以看到正常打印响应结果:</p><pre tabindex=0><code>echo:zhangsan
</code></pre><p>至此，该网关已经实现了对<code>nacos-provider</code>服务的路由转发，用户无需知道（也不应该知道）<code>nacos-provider</code>的访问地址，直接可以通关网关进行访问。</p><h3 id=二路由断言与过滤>（二）路由断言与过滤<a hidden class=anchor aria-hidden=true href=#二路由断言与过滤>#</a></h3><p>上述配置文件中，<code>Path</code>请求路径断言由<code>PathRoutePredicateFactory</code>处理，<code>AddResponseHeader</code>由<code>AddResponseHeaderGatewayFilterFactory</code>处理，断言工厂和路由过滤器工厂的详细信息可参见官网<a href=https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories>Route Predicate Factories</a>与<a href=https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories>GatewayFilter Factories</a>。</p><p>除了上述配置文件中定义的路由专用过滤器（<code>routes.filters</code>）和默认过滤器（<code>default-filters</code>）外，SpringCloudGateway还支持一种可定制性更强的全局过滤器（<code>GlobalFilter</code>）。一个示例如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Component</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Order</span>(<span style=color:#f92672>-</span>1)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AddResponseHeaderGlobalFilter</span> <span style=color:#66d9ef>implements</span> GlobalFilter {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Mono<span style=color:#f92672>&lt;</span>Void<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>filter</span>(ServerWebExchange exchange, GatewayFilterChain chain) {
</span></span><span style=display:flex><span>        ServerHttpResponse response <span style=color:#f92672>=</span> exchange.<span style=color:#a6e22e>getResponse</span>();
</span></span><span style=display:flex><span>        response.<span style=color:#a6e22e>getHeaders</span>().<span style=color:#a6e22e>set</span>(<span style=color:#e6db74>&#34;X-Response-Global&#34;</span>, <span style=color:#e6db74>&#34;Global&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> chain.<span style=color:#a6e22e>filter</span>(exchange);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>该过滤器与上述配置文件中的<code>AddResponseHeader</code>过滤器实现一样的功能：增强响应头。</p><p>再次重启应用，并发送请求：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -i <span style=color:#e6db74>&#34;http://localhost:8888/echo?name=zhangsan&#34;</span> <span style=color:#75715e># curl -i参数打印响应头</span>
</span></span></code></pre></div><p>响应结果如下:</p><pre tabindex=0><code>HTTP/1.1 200 OK
X-Response-Default: Default
X-Response-Special: Special
X-Response-Global: Global
Content-Type: text/plain;charset=UTF-8
Content-Length: 13
Date: Sat, 10 Jun 2023 06:37:58 GMT

echo:zhangsan
</code></pre><p>可以看到，三个过滤器都生效了。上述过滤器存在以下执行顺序：</p><ul><li>以Order值排序。全局过滤器的Order由用户指定（使用<code>@Order</code>注解或实现<code>Ordered</code>接口）。默认过滤器和路由专用过滤器的Order则从1开始计数，按照定义的顺序累加，同时，默认过滤器与专用过滤器的Order值独立累加。</li><li>若Order值一致，则以默认过滤器 > 路由专用过滤器 > 全局过滤器排序。</li></ul><h2 id=二k8s中的服务网关>二、K8S中的服务网关<a hidden class=anchor aria-hidden=true href=#二k8s中的服务网关>#</a></h2><h3 id=一启动一个应用>（一）启动一个应用<a hidden class=anchor aria-hidden=true href=#一启动一个应用>#</a></h3><ol><li>启动一个deployment</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create deployment web --image<span style=color:#f92672>=</span>nginx
</span></span></code></pre></div><ol start=2><li>暴露一个service</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl expose deployment web --type<span style=color:#f92672>=</span>NodePort --port<span style=color:#f92672>=</span><span style=color:#ae81ff>8080</span> --target-port<span style=color:#f92672>=</span><span style=color:#ae81ff>80</span>
</span></span><span style=display:flex><span>kubectl get service web
</span></span></code></pre></div><ol start=3><li>通过minikube调用服务</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube service web --url <span style=color:#75715e># 输出类似于 http://192.168.49.2:31959</span>
</span></span><span style=display:flex><span>curl http://192.168.49.2:31959
</span></span></code></pre></div><blockquote><p>192.168.49.2是minikube的集群ip，使用ifconfig命令查看网络适配器情况，可以看到一个minikube的专用IP网段192.168.49.1。</p></blockquote><p>正常将会显示nginx的首页html文件内容。这是通过minikube自带的service指令实现访问minikube内部service的方法，后续将会基于Ingress提供更通用的外部访问服务的方法。</p><h3 id=二启用ingress控制器>（二）启用Ingress控制器<a hidden class=anchor aria-hidden=true href=#二启用ingress控制器>#</a></h3><p>在使用Ingress之前，需要先启用Ingress控制器。Minikube支持在本地环境快速启用Ingress控制器，下面将以Minikube为例介绍Ingress的配置过程。</p><blockquote><p>生产环境Ingress控制器可以参考<a href=https://kubernetes.github.io/ingress-nginx/deploy/>Ingress-Nginx Controller Installation Guide</a>。</p></blockquote><ol><li>启动minikube</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube start --image-mirror-country<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;cn&#39;</span>
</span></span></code></pre></div><ol start=2><li>启用Ingress控制器</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube addons enable ingress
</span></span></code></pre></div><blockquote><p>国内环境可能拉取不了镜像，可以参考附录<a href=#minikube%E5%9C%A8%E5%9B%BD%E5%86%85%E7%8E%AF%E5%A2%83%E5%90%AF%E7%94%A8addons%E6%96%B9%E6%B3%95>minikube在国内环境启用addons方法</a>。</p></blockquote><ol start=3><li>查看Ingress控制器状态</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -n ingress-nginx
</span></span></code></pre></div><p>结果如下：</p><pre tabindex=0><code>NAME                                        READY   STATUS      RESTARTS   AGE
ingress-nginx-admission-create-x98cn        0/1     Completed   0          90m
ingress-nginx-admission-patch-mscpc         0/1     Completed   0          90m
ingress-nginx-controller-7b7b49467c-4kt7m   1/1     Running     0          90m
</code></pre><h3 id=三创建ingress>（三）创建Ingress<a hidden class=anchor aria-hidden=true href=#三创建ingress>#</a></h3><ol><li>定义Ingress配置文件</li></ol><p><code>example-ingress.yaml</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>networking.k8s.io/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Ingress</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>example-ingress</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>annotations</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>nginx.ingress.kubernetes.io/rewrite-target</span>: <span style=color:#ae81ff>/$1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>rules</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>host</span>: <span style=color:#ae81ff>hello-world.info</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>http</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>paths</span>:
</span></span><span style=display:flex><span>          - <span style=color:#f92672>path</span>: <span style=color:#ae81ff>/</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>pathType</span>: <span style=color:#ae81ff>Prefix</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>backend</span>:
</span></span><span style=display:flex><span>              <span style=color:#f92672>service</span>:
</span></span><span style=display:flex><span>                <span style=color:#f92672>name</span>: <span style=color:#ae81ff>web</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>port</span>:
</span></span><span style=display:flex><span>                  <span style=color:#f92672>number</span>: <span style=color:#ae81ff>8080</span>
</span></span></code></pre></div><p>该配置文件定义了<code>hello-world.info</code>域名到<code>web</code>这个<code>service</code>的转发规则。</p><ol start=2><li>启动Ingress</li></ol><pre tabindex=0><code>kubectl create -f example-ingress.yaml
</code></pre><ol start=3><li>查看Ingress状态</li></ol><pre tabindex=0><code>kubectl get ingress example-ingress
</code></pre><p>结果如下：</p><pre tabindex=0><code>NAME              CLASS   HOSTS              ADDRESS        PORTS   AGE
example-ingress   nginx   hello-world.info   192.168.49.2   80      44s
</code></pre><ol start=4><li>通过Ingress访问服务</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl --resolve <span style=color:#e6db74>&#34;hello-world.info:80:</span><span style=color:#66d9ef>$(</span> minikube ip <span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span> -i http://hello-world.info
</span></span></code></pre></div><p>正常将会显示nginx的首页html文件内容。其中<code>minikube ip</code>是minikube的集群IP（192.168.49.2），<code>curl --resolve</code>定义了域名解析（也可在本机host中配置）。</p><p>至此，该Ingress实现了以<code>hello-world.info</code>域名为入口，到pod内部的流量转发。</p><p>后续可按需基于<a href=https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/#ingress-rules>Ingress规则</a>配置更多的服务路由转发策略。</p><h2 id=三总结>三、总结<a hidden class=anchor aria-hidden=true href=#三总结>#</a></h2><p>SpringCloud通过SpringCloudGateway等组件实现网关。SpringCloudGateway是用Java开发，可定制性更强。其包括：服务路由、断言、过滤、断路器支持、服务发现支持、限流等功能。</p><p>K8S通过Ingress实现网关，除了前面描述的服务路由功能外，Ingress也支持其它网关功能（如：鉴权、限流等等）。Ingress服务需要依赖于特定的Ingress控制器，比如NGINX Ingress Controller。NGINX Ingress网关的功能更多地依赖于NGINX本身的特性，有关NGINX Ingress的更多特性，也可参见其<a href=https://docs.nginx.com/nginx-ingress-controller/>官网</a>。</p><p>与SpringCloud与K8S中的服务配置中类似：SpringCloud偏向于开发，而K8S则更偏向于运维。有关技术选型，需视情况而定。</p><h2 id=附录>附录<a hidden class=anchor aria-hidden=true href=#附录>#</a></h2><h3 id=minikube在国内环境启用addons方法>minikube在国内环境启用addons方法<a hidden class=anchor aria-hidden=true href=#minikube在国内环境启用addons方法>#</a></h3><ol><li>在本地拉取docker镜像</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/nginx-ingress-controller:v1.7.0
</span></span><span style=display:flex><span>docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/kube-webhook-certgen:v20230312-helm-chart-4.5.2-28-g66a760794
</span></span></code></pre></div><p>版本号可按需修改。</p><ol start=2><li>将本地镜像加载到minikube集群中</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube image load registry.cn-hangzhou.aliyuncs.com/google_containers/nginx-ingress-controller:v1.7.0
</span></span><span style=display:flex><span>minikube image load registry.cn-hangzhou.aliyuncs.com/google_containers/kube-webhook-certgen:v20230312-helm-chart-4.5.2-28-g66a760794
</span></span></code></pre></div><p>上一步的<code>docker pull</code>不是必须的。如果上一步执行了<code>docker pull</code>，这里的<code>load</code>命令就会从本地Docker镜像中拷贝，反之则从远程仓库拉取。</p><ol start=3><li>启用addons，并修改镜像地址</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube addons enable ingress --images<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;KubeWebhookCertgenCreate=registry.cn-hangzhou.aliyuncs.com/google_containers/kube-webhook-certgen:v20230312-helm-chart-4.5.2-28-g66a760794,KubeWebhookCertgenPatch=registry.cn-hangzhou.aliyuncs.com/google_containers/kube-webhook-certgen:v20230312-helm-chart-4.5.2-28-g66a760794,IngressController=google_containers/nginx-ingress-controller:v1.7.0&#34;</span> --registries<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;IngressController=registry.cn-hangzhou.aliyuncs.com&#34;</span>
</span></span></code></pre></div><blockquote><p>参考文档</p></blockquote><ol><li>《深入理解SpringCloud与实战 方剑 著》</li><li><a href=https://spring.io/projects/spring-cloud/>SpringCloud官方网站</a></li><li><a href=https://www.bilibili.com/video/BV1LQ4y127n4>黑马程序员SpringCloud微服务技术栈教程</a></li><li><a href=https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/>Kubernetes Ingress 介绍</a></li><li><a href=https://kubernetes.io/zh-cn/docs/tasks/access-application-cluster/ingress-minikube/>在 Minikube 环境中使用 NGINX Ingress 控制器配置 Ingress</a></li><li><a href=https://kubernetes.github.io/ingress-nginx/deploy/>Ingress-Nginx Controller Installation Guide</a></li><li><a href=https://docs.nginx.com/nginx-ingress-controller/>NGINX Ingress Controller</a></li><li><a href=https://juejin.cn/post/7165777147959705608>Minikube安装ingress插件的有效方法</a></li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://luanrz.github.io/tags/java/>Java</a></li><li><a href=https://luanrz.github.io/tags/spring/>Spring</a></li></ul><nav class=paginav><a class=prev href=https://luanrz.github.io/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/redis%E5%88%86%E5%B8%83%E5%BC%8Fid%E5%AE%9E%E7%8E%B0/><span class=title>« 上一页</span><br><span>Redis分布式ID实现</span>
</a><a class=next href=https://luanrz.github.io/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/springcloud%E4%B8%8Ek8s%E4%B8%AD%E7%9A%84%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86/><span class=title>下一页 »</span><br><span>SpringCloud与K8S中的配置管理</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://luanrz.github.io/>luanrz's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>