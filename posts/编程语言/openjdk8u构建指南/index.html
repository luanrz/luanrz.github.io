<!doctype html><html lang=zh dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>OpenJDK8u构建指南 | luanrz's blog</title><meta name=keywords content="Java,JVM"><meta name=description content="官方OpenJdk8u构建指南个人翻译版本。官方地址为README-builds.html
介绍
这个README文件包含了OpenJDK的构建说明。构建OpenJDK的源码需要一定的专业技术知识。"><meta name=author content><link rel=canonical href=https://luanrz.github.io/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/openjdk8u%E6%9E%84%E5%BB%BA%E6%8C%87%E5%8D%97/><link crossorigin=anonymous href=/assets/css/stylesheet.5ed58f4ac5cb2b1025742e6161056c468c3232b9bfc72705b7f9f2da355ff7f3.css integrity="sha256-XtWPSsXLKxAldC5hYQVsRowyMrm/xycFt/ny2jVf9/M=" rel="preload stylesheet" as=style><link rel=icon href=https://luanrz.github.io/images/icon.jpg><link rel=icon type=image/png sizes=16x16 href=https://luanrz.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://luanrz.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://luanrz.github.io/apple-touch-icon.png><link rel=mask-icon href=https://luanrz.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://luanrz.github.io/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/openjdk8u%E6%9E%84%E5%BB%BA%E6%8C%87%E5%8D%97/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script>const loadScript=(e,t)=>{var n=document.createElement("script");n.onerror=e=>{throw new URIError("The script "+e.target.src+" didn't load correctly.")},t&&(n.onload=t),document.head.insertAdjacentElement("beforeend",n),n.src=e},loadPlantUMLOnNeed=()=>{let e="language-plantuml";document.querySelectorAll("[class^="+e+"]").length>0&&loadScript("https://fastly.jsdelivr.net/gh/jmnote/plantuml-encoder@1.2.4/dist/plantuml-encoder.min.js",()=>{(function(){Array.prototype.forEach.call(document.querySelectorAll("[class^="+e+"]"),function(e){let t=document.createElement("IMG");t.loading="lazy",t.src="http://www.plantuml.com/plantuml/svg/~1"+plantumlEncoder.encode(e.innerText),e.parentNode.insertBefore(t,e),e.style.display="none"})})(),console.log("PlantUML init done")})};window.addEventListener("load",function(){loadPlantUMLOnNeed()})</script><meta property="og:url" content="https://luanrz.github.io/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/openjdk8u%E6%9E%84%E5%BB%BA%E6%8C%87%E5%8D%97/"><meta property="og:site_name" content="luanrz's blog"><meta property="og:title" content="OpenJDK8u构建指南"><meta property="og:description" content="官方OpenJdk8u构建指南个人翻译版本。官方地址为README-builds.html
介绍 这个README文件包含了OpenJDK的构建说明。构建OpenJDK的源码需要一定的专业技术知识。"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-01-20T17:42:00+00:00"><meta property="article:modified_time" content="2020-01-20T17:42:00+00:00"><meta property="article:tag" content="Java"><meta property="article:tag" content="JVM"><meta name=twitter:card content="summary"><meta name=twitter:title content="OpenJDK8u构建指南"><meta name=twitter:description content="官方OpenJdk8u构建指南个人翻译版本。官方地址为README-builds.html
介绍
这个README文件包含了OpenJDK的构建说明。构建OpenJDK的源码需要一定的专业技术知识。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://luanrz.github.io/posts/"},{"@type":"ListItem","position":3,"name":"OpenJDK8u构建指南","item":"https://luanrz.github.io/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/openjdk8u%E6%9E%84%E5%BB%BA%E6%8C%87%E5%8D%97/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"OpenJDK8u构建指南","name":"OpenJDK8u构建指南","description":"官方OpenJdk8u构建指南个人翻译版本。官方地址为README-builds.html\n介绍 这个README文件包含了OpenJDK的构建说明。构建OpenJDK的源码需要一定的专业技术知识。\n","keywords":["Java","JVM"],"articleBody":"官方OpenJdk8u构建指南个人翻译版本。官方地址为README-builds.html\n介绍 这个README文件包含了OpenJDK的构建说明。构建OpenJDK的源码需要一定的专业技术知识。\n!!!!!!!!!!!!!!! 这是对这份文档的一次重大改写!!!!!!!!!!!!!!!\n概述如下：\n当前构建方式是“configure \u0026\u0026 make” GNU make的版本应当大于或等于3.81 构建是可伸缩的，比如：可以使用更多的处理器来完成构建过程，以减少构建时间 嵌套与递归的make调用已经明显减少，fork/exec 与子进程生成的总量也相应减少 不再支持 Windows MKS Windows Vistual Studio 的 vsvars*.bat 和 vcvars*.bat 等文件会自动运行 构建OpenJDK时，不再使用Ant 不再支持在配置构建过程时使用 ALT_* 环境变量 目录 介绍\n使用Mercurial\n获取源码 仓库结构 源码规范 构建\n系统设置 Linux Solaris MacOSX Windows Configure Make 测试\n附录A：提示和技巧\n常见问题解答 构建性能技巧 故障排查 附录B：GNU-Make信息\n附录C：构建环境\n使用Mercurial OpenJDK源码由版本控制系统 Mercurial 维护，如果你还不熟悉 Mercurial ，请参阅 Beginner Guides 或参考 Mercurial Book 。本书的前几章对“Mercurial是什么“以及“Mercurial如何工作”进行了出色的概述。\n获取源码 执行主仓库下的 `get_source.sh 命令，获取 OpenJDK Mercurial 仓库的全部内容。\nhg clone http://hg.openjdk.java.net/jdk8/jdk8 YourOpenJDK cd YourOpenJDK bash ./get_source.sh 当你拥有了所有的仓库之后，请记住，每个的仓库都是独立的。你也可以重新执行./get_source.sh，随时拉取所有仓库的最新变更集。这些内嵌的仓库被称作“forest”（树形结构），有多种方法可以为每个仓库执行相同的hg命令。例如，make/scripts/hgforest.sh脚本就可以为每个仓库执行相同的hg命令，如下：\ncd YourOpenJDK bash ./make/scripts/hgforest.sh status 仓库结构 仓库及其内容概述\n仓库 内容概述 .(root) 通用配置与 makefile 逻辑 hotspot 构建 OpenJDK Hotspot 虚拟机所需的源代码和 make 文件 langtools OpenJDK javac 和 language tools 的源代码 jdk 构建OpenJDK运行时库与其它文件所需的的源代码和 make 文件 jaxp OpenJDK JAXP 功能的源代码 jaxws OpenJDK JAX-WS 功能的源代码 corba OpenJDK Corba 功能的源代码 nashorn OpenJDK JavaScript 功能的源代码 源码规范 一些基本的规范：\n源文件中空格的使用是受限制的：不能有制表符、行末不能有空格、文件不能以一个以上的空行结束（源文件包括.java， .c， .h， .cpp， 和 .hpp 文件） 不应该将具有可执行权限的文件添加到源仓库中去 所有生成的文件需要与源代码控制系统所维护管理的文件保持隔离，生成的文件应当存放在顶层的 build/ 目录下 默认的构建过程应该构建 product ，而不是其它。可供构建的选项如下：product（优化版本）、debug（未优化版本，附带-g的断言逻辑）、fastdebug（优化版本，附带-g的断言逻辑） 每个仓库必须存在.hgignore 文件，它必须包含 build/、dist/，可以包含nbproject/private等类似的文件夹，不能包含仓库中的 src/ 、 test/ 及其它在仓库管理范围内的任何内容 目录名和文件名不应该包含空格或非打印字符 生成的文件或二进制文件不应该添加到仓库中（包括 javah 输出）。对于这条规则有一些特例，特别是一些生成的 configure 脚本 不应该将不需要用于构建或测试的文件添加到仓库 构建 构建OpenJDK的第一步是确保系统本身已经拥有了构建OpenJDK所需要的一切。一旦系统设置完成，通常就不再需要执行这一步了。\n构建OpenJDK现在可以通过运行一个 configure 脚本来完成，这个脚本会尝试查找并验证你是否已经拥有所需的一切，然后运行 make 命令，如下所示：\nbash ./configure make all 在可能的情况下， configure 文件会尝试在默认位置或组件指定的变量设置中来定位不同的组件，当正常的缺省设置失效或无法找到组件时，可能需要额外的 configure 选项来帮助 configure 找到构建所需的工具，如果构建过程中提示缺失软件包，你可能需要在安装指定软件包之后重新执行构建操作。\n注意：configure 脚本文件没有执行权限，需要使用 bash 命令显式地运行它，请参看源码规范\n系统设置 在尝试使用操作系统去构建 OpenJDK 之前，需要进行一些非常基本的系统设置。对所有操作系统来说：\n请确保 GNU make 工具的版本大于或等于3.8.1，执行\"make -version“来查看make的版本\n安装一个引导 JDK。所有的 OpenJDK 构建都需要访问一个先前发布的 JDK ，这个 JDK 叫作 bootstrap JDK 或者 boot JDK 。一般的规则是，这个引导 JDK 必须是 JDK 上一个主要版本的实例。此外，可能需要使用一个特定的 update 级别或更高级别的引导 JDK来完成构建操作。\n构建 JDK8 需要使用 Update7 或以上版本的 JDK7， JDK8 的开发者不应该把 JDK8 当作引导 JDK ， 以确保由 JDK7 所构建的系统部分不会引入 JDK8 的依赖\nJDK7 二进制文件可以在 Oracle的 JDK 7 下载站点 下载。构建过程中，引导 JDK 能够正常访问是非常重要的，你应该将引导 JDK 的 bin 路径添加到 PATH 环境变量中去。如果 configure 找不到这个引导 JDK ，你可能需要使用 configure 选项 --with-boot-jdk 来指定它的位置\n确保 GNU make、引导 JDK 和编译器都位于你的 PATH 环境变量中\n针对特定系统： （仅翻译了Linux，Sloaris、Windows、Mac OS X 都没有翻译）\nLinux 安装所有需要的软件开发包，包括alsa、freetype、cups和xrender\n使用 Linux 时，尽量使用系统包，而不是自己构建或从其他地方获取。大多数Linux都可以使用系统包。\n注意，有些 Linux 系统有预先设置环境变量的习惯，例如，在Linux 系统中安装完 JDK 后， JAVA_HOME 可能会预先定义到你的环境变量中。你可能需要 unset JAVA_HOME。建议运行 env 命令，并验证你从系统默认设置中获取的环境变量对于构建 OpenJDK 是否有意义。\nConfigure configure 脚本的基本调用方法如下：\nbash ./configure [options] 上述操作将会创建一个含有 “configuration” 的输出目录，并为构建结果设置一个子目录，构建结果目录一般看起来像：\nbuild/linux-x64-normal-server-release configure 会计算出你正在哪个系统上运行，以及全部所需构建组件位于何处。如果你已经安装了构建所需的所有先决条件，它就会找到所有内容。如果不能自动检测到任何组件，它就会退出并告诉你问题所在。发生这种情况时，请阅读下面的配置选项中的更多内容。\n一些例子：\n描述 Configure 命令 含有指定freetype的32位版本 bash ./configure --with-freetype=/cygdrive/c/freetype-i586 --with-target-bits=32 fastdebug级别的64位版本 bash ./configure --enable-debug --with-target-bits=64 配置选项 OpenJDK configure 选项的完整细节可以通过以下命令获取：\nbash ./configure --help=short 使用 -help 能看到所有可用的 configure 选项，你可以生成任意数量的不同配置，如debug、release、32、64等等。一些比较常用的 configure 选项如下：\nConfigure 选项 描述 –enable-debug 设置debug级别为fastdebug （这是--with-debug-level=fastdebug的简写）。 –with-alsa=path 设置ALSA（Linux声音驱动程序）的位置。在Linux中，需要使用大于或等于0.9.1版本的 ALSA 文件来构建OpenJDK.。这些 Linux 文件通常可以从“libasound”开发包的“alsa”中获得，强烈建议使用由当前Linux发行版所提供的软件包。 –with-boot-jdk=path 选择引导 JDK。 –with-boot-jdk-jvmargs=“args” 提供用于运行引导JDK的JVM选项。 –with-cacerts=path 选择cacerts文件的路径。 参看 证书颁发机构 以更好地理解证书授权概念。“cacerts”文件表示CA证书的全局密钥库，在JDK和JRE二进制包中，“cacerts”文件包含来自几个公共CA的根CA证书(公共CA包括VeriSign、Thawte和Baltimore等)。源文件包含了一个没有CA根证书的cacerts文件。正式构建时需要获得每个公共CA的许可，并将证书包含到它们自己的自定义cacerts文件中。如果cacerts文件没有正确包含公共CA的许可，将导致运行时证书链的验证异常。默认情况下，会提供一个空的cacerts文件，这对大多数JDK开发人员来说应该没有问题。 –with-cups=path 选择CUPS安装路径在Solaris和Linux上构建OpenJDK需要CUPS(UNIX通用打印系统)头文件。Solaris中，可以通过安装Solaris Software Companion的CD/DVD中的SFWcups软件包来获得头文件，这些头文件通常会安装到目录/opt/sfw/cups中。CUPS头文件可以从www.cups.org下载。 –with-cups-include=path 选择CUPS头文件路径。 –with-debug-level=level 选择调试信息信息级别，包括release、fastdebug及slowdebug。 –with-dev-kit=path 选择编译与开发工具的路径。 –with-freetype=path 选择要使用的freetype文件。预期在lib/目录下有freetype的库文件，在include/目录下有freetype的头文件。 freetype的版本需要大于或等于2.3。在Unix系统上，所需的文件可能已经内置了，但你仍然可能需要升级它们。注意，freetype必须是同时包含库文件和头文件的开发版本。你可以从FreeType 站点下载最新的FreeType从头开始构建freetype 2库也是可以的，但是在Windows上构建可能需要参考Windows freetype DLL构建说明注意，在默认情况下，由于许可限制原因，FreeType构建时禁用了字节码提示支持。在这种情况下，文字的外观与大小将与Sun的JDK官方版本有所差异。有关更多信息，请参见SourceForge FreeType2主页。 –with-import-hotspot=path 选择以前版本的hotspot二进制文件的位置，以避免构建hotspot。 –with-target-bits=arg 选择构建位数，包括32与64。 –with-jvm-variants=variants 选择要构建的JVM变体，包括server, client, kernel, zero 和 zeroshark，多个选项用逗号分割。 –with-memory-size=size 选择 GNU make 可运用的 RAM 上限。 –with-msvcr-dll=path 选择msvcr100.dll文件的位置， 这个文件是 Visual Studio的C/C++运行时库，在使用Windows构建时会用到。这个文件通常是从Visual Studio 2010的redist目录中自动获得的。 –with-num-cores=cores 选择要使用的内核数量（处理器数量或CPU数量）。 –with-x=path 选择X11和xrender文件的路径。在Solaris和Linux上构建OpenJDK时需要使用XRender的扩展头文件，Linux头文件通常可以从\"Xrender\"开发包中获得，建议使用由当前Linux发行版所提供的软件包。Solaris的XRender头文件和和其它X11头文件在新版本的Solaris的SFWxwinc包中，它们位于/usr/X11/include/X11/extensions/Xrender.h或/usr/openwin/share/include/X11/extensions/Xrender.h。 Make make 的基本调用方法如下：\nmake all 执行这个命令将会在构建结果目录下开始构建，构建结果目录由configure脚本生成\n运行make help可以获取更多支持的target信息\n以下是一些大家普遍感兴趣的target:\ntarget 描述 空 构建所有内容，但不包括镜像 all 构建所有内容，且包括镜像 all-conf 构建所有配置 images 构建完整的j2sdk和j2re镜像 install 将生成的镜像安装到本地，安装路径一般是/usr/local clean 删除所有由make生成的文件，不包括由configure生成的文件 dist-clean 删除所有由make和configure生成的文件（基本上是重置配置） help 提供一些make命令的帮助，包含了一些常用的target 测试 构建完成之后，你应该可以在输出目录的j2sdk-image子目录下看到生成的二进制文件和其它相关联的文件。特别是，build/*/images/j2sdk-image/bin目录应该包含了当前配置的OpenJDK工具的可执行文件。\n如果需要测试工具jtreg的话，你可以参见jtreg站点。仓库中提供的回归测试可以使用以下命令运行：\ncd test \u0026\u0026 make PRODUCT_HOME=`pwd`/../build/*/images/j2sdk-image all 附录A：提示和技巧 常见问题解答 构建性能技巧 故障排查 附录B：GNU-Make信息 附录C：构建环境 ","wordCount":"4609","inLanguage":"zh","datePublished":"2020-01-20T17:42:00Z","dateModified":"2020-01-20T17:42:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://luanrz.github.io/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/openjdk8u%E6%9E%84%E5%BB%BA%E6%8C%87%E5%8D%97/"},"publisher":{"@type":"Organization","name":"luanrz's blog","logo":{"@type":"ImageObject","url":"https://luanrz.github.io/images/icon.jpg"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://luanrz.github.io/ accesskey=h title="luanrz's blog (Alt + H)">luanrz's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://luanrz.github.io/ title=首页><span>首页</span></a></li><li><a href=https://luanrz.github.io/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://luanrz.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://luanrz.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://luanrz.github.io/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">OpenJDK8u构建指南</h1><div class=post-meta><span title='2020-01-20 17:42:00 +0000 UTC'>2020-01-20</span>&nbsp;·&nbsp;<span>10 分钟</span>&nbsp;·&nbsp;<span>4609 字</span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e4%bb%8b%e7%bb%8d aria-label=介绍>介绍</a></li><li><a href=#%e7%9b%ae%e5%bd%95 aria-label=目录>目录</a></li><li><a href=#%e4%bd%bf%e7%94%a8mercurial aria-label=使用Mercurial>使用Mercurial</a><ul><li><a href=#%e8%8e%b7%e5%8f%96%e6%ba%90%e7%a0%81 aria-label=获取源码>获取源码</a></li><li><a href=#%e4%bb%93%e5%ba%93%e7%bb%93%e6%9e%84 aria-label=仓库结构>仓库结构</a></li><li><a href=#%e6%ba%90%e7%a0%81%e8%a7%84%e8%8c%83 aria-label=源码规范>源码规范</a></li></ul></li><li><a href=#%e6%9e%84%e5%bb%ba aria-label=构建>构建</a><ul><li><a href=#%e7%b3%bb%e7%bb%9f%e8%ae%be%e7%bd%ae aria-label=系统设置>系统设置</a><ul><li><a href=#linux aria-label=Linux>Linux</a></li></ul></li><li><a href=#configure aria-label=Configure>Configure</a><ul><li><a href=#%e9%85%8d%e7%bd%ae%e9%80%89%e9%a1%b9 aria-label=配置选项>配置选项</a></li></ul></li><li><a href=#make aria-label=Make>Make</a></li></ul></li><li><a href=#%e6%b5%8b%e8%af%95 aria-label=测试>测试</a></li><li><a href=#%e9%99%84%e5%bd%95a%e6%8f%90%e7%a4%ba%e5%92%8c%e6%8a%80%e5%b7%a7 aria-label=附录A：提示和技巧>附录A：提示和技巧</a><ul><li><a href=#%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98%e8%a7%a3%e7%ad%94 aria-label=常见问题解答>常见问题解答</a></li><li><a href=#%e6%9e%84%e5%bb%ba%e6%80%a7%e8%83%bd%e6%8a%80%e5%b7%a7 aria-label=构建性能技巧>构建性能技巧</a></li><li><a href=#%e6%95%85%e9%9a%9c%e6%8e%92%e6%9f%a5 aria-label=故障排查>故障排查</a></li></ul></li><li><a href=#%e9%99%84%e5%bd%95bgnu-make%e4%bf%a1%e6%81%af aria-label=附录B：GNU-Make信息>附录B：GNU-Make信息</a></li><li><a href=#%e9%99%84%e5%bd%95c%e6%9e%84%e5%bb%ba%e7%8e%af%e5%a2%83 aria-label=附录C：构建环境>附录C：构建环境</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>官方OpenJdk8u构建指南个人翻译版本。官方地址为<a href=http://hg.openjdk.java.net/jdk8u/jdk8u/file/120809c21ad7/README-builds.html>README-builds.html</a></p><h1 id=介绍>介绍<a hidden class=anchor aria-hidden=true href=#介绍>#</a></h1><p>这个README文件包含了OpenJDK的构建说明。构建OpenJDK的源码需要一定的专业技术知识。</p><p>!!!!!!!!!!!!!!! 这是对这份文档的一次重大改写!!!!!!!!!!!!!!!</p><p>概述如下：</p><ul><li>当前构建方式是“<code>configure && make</code>”</li><li>GNU make的版本应当大于或等于3.81</li><li>构建是可伸缩的，比如：可以使用更多的处理器来完成构建过程，以减少构建时间</li><li>嵌套与递归的make调用已经明显减少，fork/exec 与子进程生成的总量也相应减少</li><li>不再支持 Windows MKS</li><li>Windows Vistual Studio 的 <code>vsvars*.bat</code> 和 <code>vcvars*.bat</code> 等文件会自动运行</li><li>构建OpenJDK时，不再使用Ant</li><li>不再支持在配置构建过程时使用 ALT_* 环境变量</li></ul><h1 id=目录>目录<a hidden class=anchor aria-hidden=true href=#目录>#</a></h1><ul><li><p><a href=#%E4%BB%8B%E7%BB%8D>介绍</a></p></li><li><p><a href=#%E4%BD%BF%E7%94%A8Mercurial>使用Mercurial</a></p><ul><li><a href=#%E8%8E%B7%E5%8F%96%E6%BA%90%E7%A0%81>获取源码</a></li><li><a href=#%E4%BB%93%E5%BA%93%E7%BB%93%E6%9E%84>仓库结构</a></li><li><a href=#%E6%BA%90%E7%A0%81%E8%A7%84%E8%8C%83>源码规范</a></li></ul></li><li><p><a href=#%E6%9E%84%E5%BB%BA>构建</a></p><ul><li><a href=#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE>系统设置</a><ul><li><a href=#linux>Linux</a></li><li><a href=#solaris>Solaris</a></li><li><a href=#macOSX>MacOSX</a></li><li><a href=#windows>Windows</a></li></ul></li><li><a href=#configure>Configure</a></li><li><a href=#make>Make</a></li></ul></li><li><p><a href=#%E6%B5%8B%E8%AF%95>测试</a></p></li><li><p><a href=#%E9%99%84%E5%BD%95a%E6%8F%90%E7%A4%BA%E5%92%8C%E6%8A%80%E5%B7%A7>附录A：提示和技巧</a></p><ul><li><a href=#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94>常见问题解答</a></li><li><a href=#%E6%9E%84%E5%BB%BA%E6%80%A7%E8%83%BD%E6%8A%80%E5%B7%A7>构建性能技巧</a></li><li><a href=#%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5>故障排查</a></li></ul></li><li><p><a href=#%E9%99%84%E5%BD%95bgnu-make%E4%BF%A1%E6%81%AF>附录B：GNU-Make信息</a></p></li><li><p><a href=#%E9%99%84%E5%BD%95c%E6%9E%84%E5%BB%BA%E7%8E%AF%E5%A2%83>附录C：构建环境</a></p></li></ul><h1 id=使用mercurial>使用Mercurial<a hidden class=anchor aria-hidden=true href=#使用mercurial>#</a></h1><p>OpenJDK源码由版本控制系统 <a href=http://mercurial.selenic.com/wiki/Mercurial>Mercurial</a> 维护，如果你还不熟悉 Mercurial ，请参阅 <a href=http://mercurial.selenic.com/wiki/BeginnersGuides>Beginner Guides</a> 或参考 <a href=http://hgbook.red-bean.com/>Mercurial Book</a> 。本书的前几章对“Mercurial是什么“以及“Mercurial如何工作”进行了出色的概述。</p><h2 id=获取源码>获取源码<a hidden class=anchor aria-hidden=true href=#获取源码>#</a></h2><p>执行主仓库下的 `get_source.sh 命令，获取 OpenJDK Mercurial 仓库的全部内容。</p><pre><code>hg clone http://hg.openjdk.java.net/jdk8/jdk8 YourOpenJDK
cd YourOpenJDK
bash ./get_source.sh
</code></pre><p>当你拥有了所有的仓库之后，请记住，每个的仓库都是独立的。你也可以重新执行<code>./get_source.sh</code>，随时拉取所有仓库的最新变更集。这些内嵌的仓库被称作“forest”（树形结构），有多种方法可以为每个仓库执行相同的<code>hg</code>命令。例如，<code>make/scripts/hgforest.sh</code>脚本就可以为每个仓库执行相同的<code>hg</code>命令，如下：</p><pre><code>cd YourOpenJDK
bash ./make/scripts/hgforest.sh status
</code></pre><h2 id=仓库结构>仓库结构<a hidden class=anchor aria-hidden=true href=#仓库结构>#</a></h2><p>仓库及其内容概述</p><table><thead><tr><th>仓库</th><th>内容概述</th></tr></thead><tbody><tr><td>.(root)</td><td>通用配置与 makefile 逻辑</td></tr><tr><td>hotspot</td><td>构建 OpenJDK Hotspot 虚拟机所需的源代码和 make 文件</td></tr><tr><td>langtools</td><td>OpenJDK javac 和 language tools 的源代码</td></tr><tr><td>jdk</td><td>构建OpenJDK运行时库与其它文件所需的的源代码和 make 文件</td></tr><tr><td>jaxp</td><td>OpenJDK JAXP 功能的源代码</td></tr><tr><td>jaxws</td><td>OpenJDK JAX-WS 功能的源代码</td></tr><tr><td>corba</td><td>OpenJDK Corba 功能的源代码</td></tr><tr><td>nashorn</td><td>OpenJDK JavaScript 功能的源代码</td></tr></tbody></table><h2 id=源码规范>源码规范<a hidden class=anchor aria-hidden=true href=#源码规范>#</a></h2><p>一些基本的规范：</p><ul><li>源文件中空格的使用是受限制的：不能有制表符、行末不能有空格、文件不能以一个以上的空行结束（源文件包括.java， .c， .h， .cpp， 和 .hpp 文件）</li><li>不应该将具有可执行权限的文件添加到源仓库中去</li><li>所有生成的文件需要与源代码控制系统所维护管理的文件保持隔离，生成的文件应当存放在顶层的 <code>build/</code> 目录下</li><li>默认的构建过程应该构建 product ，而不是其它。可供构建的选项如下：product（优化版本）、debug（未优化版本，附带-g的断言逻辑）、fastdebug（优化版本，附带-g的断言逻辑）</li><li>每个仓库必须存在<code>.hgignore</code> 文件，它必须包含 <code>build/</code>、<code>dist/</code>，可以包含<code>nbproject/private</code>等类似的文件夹，不能包含仓库中的 <code>src/</code> 、 <code>test/</code> 及其它在仓库管理范围内的任何内容</li><li>目录名和文件名不应该包含空格或非打印字符</li><li>生成的文件或二进制文件不应该添加到仓库中（包括 <code>javah</code> 输出）。对于这条规则有一些特例，特别是一些生成的 configure 脚本</li><li>不应该将不需要用于构建或测试的文件添加到仓库</li></ul><h1 id=构建>构建<a hidden class=anchor aria-hidden=true href=#构建>#</a></h1><p>构建OpenJDK的第一步是确保系统本身已经拥有了构建OpenJDK所需要的一切。一旦系统设置完成，通常就不再需要执行这一步了。</p><p>构建OpenJDK现在可以通过运行一个 configure 脚本来完成，这个脚本会尝试查找并验证你是否已经拥有所需的一切，然后运行 make 命令，如下所示：</p><pre><code>bash ./configure
make all
</code></pre><p>在可能的情况下， <code>configure</code> 文件会尝试在默认位置或组件指定的变量设置中来定位不同的组件，当正常的缺省设置失效或无法找到组件时，可能需要额外的 <code>configure</code> 选项来帮助 <code>configure</code> 找到构建所需的工具，如果构建过程中提示缺失软件包，你可能需要在安装指定软件包之后重新执行构建操作。</p><p>注意：<code>configure</code> 脚本文件没有执行权限，需要使用 <code>bash</code> 命令显式地运行它，请参看源码规范</p><h2 id=系统设置>系统设置<a hidden class=anchor aria-hidden=true href=#系统设置>#</a></h2><p>在尝试使用操作系统去构建 OpenJDK 之前，需要进行一些非常基本的系统设置。对所有操作系统来说：</p><ul><li><p>请确保 GNU make 工具的版本大于或等于3.8.1，执行"<code>make -version</code>&ldquo;来查看make的版本</p></li><li><p>安装一个引导 JDK。所有的 OpenJDK 构建都需要访问一个先前发布的 JDK ，这个 JDK 叫作 <code>bootstrap JDK</code> 或者 <code>boot JDK</code> 。一般的规则是，这个引导 JDK 必须是 JDK 上一个主要版本的实例。此外，可能需要使用一个特定的 update 级别或更高级别的引导 JDK来完成构建操作。</p><p>构建 JDK8 需要使用 Update7 或以上版本的 JDK7， JDK8 的开发者不应该把 JDK8 当作引导 JDK ， 以确保由 JDK7 所构建的系统部分不会引入 JDK8 的依赖</p><p>JDK7 二进制文件可以在 Oracle的 <a href=http://www.oracle.com/technetwork/java/javase/downloads/index.html>JDK 7 下载站点</a> 下载。构建过程中，引导 JDK 能够正常访问是非常重要的，你应该将引导 JDK 的 <code>bin</code> 路径添加到 <code>PATH</code> 环境变量中去。如果 <code>configure</code> 找不到这个引导 JDK ，你可能需要使用 <code>configure</code> 选项 <code>--with-boot-jdk</code> 来指定它的位置</p></li><li><p>确保 GNU make、引导 JDK 和编译器都位于你的 PATH 环境变量中</p></li></ul><p>针对特定系统：
（仅翻译了Linux，Sloaris、Windows、Mac OS X 都没有翻译）</p><h3 id=linux>Linux<a hidden class=anchor aria-hidden=true href=#linux>#</a></h3><p>安装所有需要的软件开发包，包括alsa、freetype、cups和xrender</p><p>使用 Linux 时，尽量使用系统包，而不是自己构建或从其他地方获取。大多数Linux都可以使用系统包。</p><p>注意，有些 Linux 系统有预先设置环境变量的习惯，例如，在Linux 系统中安装完 JDK 后， <code>JAVA_HOME</code> 可能会预先定义到你的环境变量中。你可能需要 unset <code>JAVA_HOME</code>。建议运行 <code>env</code> 命令，并验证你从系统默认设置中获取的环境变量对于构建 OpenJDK 是否有意义。</p><h2 id=configure>Configure<a hidden class=anchor aria-hidden=true href=#configure>#</a></h2><p><code>configure</code> 脚本的基本调用方法如下：</p><pre><code>bash ./configure [options]
</code></pre><p>上述操作将会创建一个含有 &ldquo;configuration&rdquo; 的输出目录，并为构建结果设置一个子目录，构建结果目录一般看起来像：</p><pre><code>build/linux-x64-normal-server-release
</code></pre><p><code>configure</code> 会计算出你正在哪个系统上运行，以及全部所需构建组件位于何处。如果你已经安装了构建所需的所有先决条件，它就会找到所有内容。如果不能自动检测到任何组件，它就会退出并告诉你问题所在。发生这种情况时，请阅读下面的配置选项中的更多内容。</p><p>一些例子：</p><table><thead><tr><th>描述</th><th>Configure 命令</th></tr></thead><tbody><tr><td>含有指定freetype的32位版本</td><td><code>bash ./configure --with-freetype=/cygdrive/c/freetype-i586 --with-target-bits=32</code></td></tr><tr><td>fastdebug级别的64位版本</td><td><code>bash ./configure --enable-debug --with-target-bits=64</code></td></tr></tbody></table><h3 id=配置选项>配置选项<a hidden class=anchor aria-hidden=true href=#配置选项>#</a></h3><p>OpenJDK <code>configure</code> 选项的完整细节可以通过以下命令获取：</p><pre><code>bash ./configure --help=short
</code></pre><p>使用 <code>-help</code> 能看到所有可用的 <code>configure</code> 选项，你可以生成任意数量的不同配置，如debug、release、32、64等等。一些比较常用的 <code>configure</code> 选项如下：</p><table><thead><tr><th>Configure 选项</th><th>描述</th></tr></thead><tbody><tr><td>&ndash;enable-debug</td><td>设置debug级别为fastdebug （这是<code>--with-debug-level=fastdebug</code>的简写）。</td></tr><tr><td>&ndash;with-alsa=path</td><td>设置ALSA（Linux声音驱动程序）的位置。在Linux中，需要使用大于或等于0.9.1版本的 ALSA 文件来构建OpenJDK.。这些 Linux 文件通常可以从“libasound”开发包的“alsa”中获得，强烈建议使用由当前Linux发行版所提供的软件包。</td></tr><tr><td>&ndash;with-boot-jdk=path</td><td>选择引导 JDK。</td></tr><tr><td>&ndash;with-boot-jdk-jvmargs=&ldquo;args&rdquo;</td><td>提供用于运行引导JDK的JVM选项。</td></tr><tr><td>&ndash;with-cacerts=path</td><td>选择cacerts文件的路径。 参看 <a href=https://zh.wikipedia.org/wiki/%E8%AF%81%E4%B9%A6%E9%A2%81%E5%8F%91%E6%9C%BA%E6%9E%84>证书颁发机构</a> 以更好地理解证书授权概念。“cacerts”文件表示CA证书的全局密钥库，在JDK和JRE二进制包中，“cacerts”文件包含来自几个公共CA的根CA证书(公共CA包括VeriSign、Thawte和Baltimore等)。源文件包含了一个没有CA根证书的cacerts文件。正式构建时需要获得每个公共CA的许可，并将证书包含到它们自己的自定义cacerts文件中。如果cacerts文件没有正确包含公共CA的许可，将导致运行时证书链的验证异常。默认情况下，会提供一个空的cacerts文件，这对大多数JDK开发人员来说应该没有问题。</td></tr><tr><td>&ndash;with-cups=path</td><td>选择CUPS安装路径在Solaris和Linux上构建OpenJDK需要CUPS(UNIX通用打印系统)头文件。Solaris中，可以通过安装Solaris Software Companion的CD/DVD中的SFWcups软件包来获得头文件，这些头文件通常会安装到目录/opt/sfw/cups中。CUPS头文件可以从<a href=www.cups.org>www.cups.org</a>下载。</td></tr><tr><td>&ndash;with-cups-include=path</td><td>选择CUPS头文件路径。</td></tr><tr><td>&ndash;with-debug-level=level</td><td>选择调试信息信息级别，包括release、fastdebug及slowdebug。</td></tr><tr><td>&ndash;with-dev-kit=path</td><td>选择编译与开发工具的路径。</td></tr><tr><td>&ndash;with-freetype=path</td><td>选择要使用的freetype文件。预期在<code>lib/</code>目录下有freetype的库文件，在<code>include/</code>目录下有freetype的头文件。 freetype的版本需要大于或等于2.3。在Unix系统上，所需的文件可能已经内置了，但你仍然可能需要升级它们。注意，freetype必须是同时包含库文件和头文件的开发版本。你可以从<a href=http://www.freetype.org/>FreeType 站点</a>下载最新的FreeType从头开始构建freetype 2库也是可以的，但是在Windows上构建可能需要参考<a href=http://freetype.freedesktop.org/wiki/FreeType_DLL>Windows freetype DLL构建说明</a>注意，在默认情况下，由于许可限制原因，FreeType构建时禁用了字节码提示支持。在这种情况下，文字的外观与大小将与Sun的JDK官方版本有所差异。有关更多信息，请参见<a href=http://freetype.sourceforge.net/freetype2/index.html>SourceForge FreeType2主页</a>。</td></tr><tr><td>&ndash;with-import-hotspot=path</td><td>选择以前版本的hotspot二进制文件的位置，以避免构建hotspot。</td></tr><tr><td>&ndash;with-target-bits=arg</td><td>选择构建位数，包括32与64。</td></tr><tr><td>&ndash;with-jvm-variants=variants</td><td>选择要构建的JVM变体，包括server, client, kernel, zero 和 zeroshark，多个选项用逗号分割。</td></tr><tr><td>&ndash;with-memory-size=size</td><td>选择 GNU make 可运用的 RAM 上限。</td></tr><tr><td>&ndash;with-msvcr-dll=path</td><td>选择msvcr100.dll文件的位置， 这个文件是 Visual Studio的C/C++运行时库，在使用Windows构建时会用到。这个文件通常是从Visual Studio 2010的redist目录中自动获得的。</td></tr><tr><td>&ndash;with-num-cores=cores</td><td>选择要使用的内核数量（处理器数量或CPU数量）。</td></tr><tr><td>&ndash;with-x=path</td><td>选择X11和xrender文件的路径。在Solaris和Linux上构建OpenJDK时需要使用XRender的扩展头文件，Linux头文件通常可以从"Xrender"开发包中获得，建议使用由当前Linux发行版所提供的软件包。Solaris的XRender头文件和和其它X11头文件在新版本的Solaris的SFWxwinc包中，它们位于<code>/usr/X11/include/X11/extensions/Xrender.h</code>或<code>/usr/openwin/share/include/X11/extensions/Xrender.h</code>。</td></tr></tbody></table><h2 id=make>Make<a hidden class=anchor aria-hidden=true href=#make>#</a></h2><p><code>make</code> 的基本调用方法如下：</p><pre><code>make all
</code></pre><p>执行这个命令将会在构建结果目录下开始构建，构建结果目录由<code>configure</code>脚本生成</p><p>运行<code>make help</code>可以获取更多支持的target信息</p><p>以下是一些大家普遍感兴趣的target:</p><table><thead><tr><th>target</th><th>描述</th></tr></thead><tbody><tr><td>空</td><td>构建所有内容，但不包括镜像</td></tr><tr><td>all</td><td>构建所有内容，且包括镜像</td></tr><tr><td>all-conf</td><td>构建所有配置</td></tr><tr><td>images</td><td>构建完整的j2sdk和j2re镜像</td></tr><tr><td>install</td><td>将生成的镜像安装到本地，安装路径一般是<code>/usr/local</code></td></tr><tr><td>clean</td><td>删除所有由<code>make</code>生成的文件，不包括由<code>configure</code>生成的文件</td></tr><tr><td>dist-clean</td><td>删除所有由<code>make</code>和<code>configure</code>生成的文件（基本上是重置配置）</td></tr><tr><td>help</td><td>提供一些make命令的帮助，包含了一些常用的target</td></tr></tbody></table><h1 id=测试>测试<a hidden class=anchor aria-hidden=true href=#测试>#</a></h1><p>构建完成之后，你应该可以在输出目录的<code>j2sdk-image</code>子目录下看到生成的二进制文件和其它相关联的文件。特别是，<code>build/*/images/j2sdk-image/bin</code>目录应该包含了当前配置的OpenJDK工具的可执行文件。</p><p>如果需要测试工具<code>jtreg</code>的话，你可以参见<a href=http://openjdk.java.net/jtreg/>jtreg站点</a>。仓库中提供的回归测试可以使用以下命令运行：</p><pre><code>cd test &amp;&amp; make PRODUCT_HOME=`pwd`/../build/*/images/j2sdk-image all
</code></pre><h1 id=附录a提示和技巧>附录A：提示和技巧<a hidden class=anchor aria-hidden=true href=#附录a提示和技巧>#</a></h1><h2 id=常见问题解答>常见问题解答<a hidden class=anchor aria-hidden=true href=#常见问题解答>#</a></h2><h2 id=构建性能技巧>构建性能技巧<a hidden class=anchor aria-hidden=true href=#构建性能技巧>#</a></h2><h2 id=故障排查>故障排查<a hidden class=anchor aria-hidden=true href=#故障排查>#</a></h2><h1 id=附录bgnu-make信息>附录B：GNU-Make信息<a hidden class=anchor aria-hidden=true href=#附录bgnu-make信息>#</a></h1><h1 id=附录c构建环境>附录C：构建环境<a hidden class=anchor aria-hidden=true href=#附录c构建环境>#</a></h1></div><footer class=post-footer><ul class=post-tags><li><a href=https://luanrz.github.io/tags/java/>Java</a></li><li><a href=https://luanrz.github.io/tags/jvm/>JVM</a></li></ul><nav class=paginav><a class=prev href=https://luanrz.github.io/posts/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/idea%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/><span class=title>« 上一页</span><br><span>IDEA插件开发环境搭建</span>
</a><a class=next href=https://luanrz.github.io/posts/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/termux%E9%85%8D%E7%BD%AE/><span class=title>下一页 »</span><br><span>Termux配置</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://luanrz.github.io/>luanrz's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>